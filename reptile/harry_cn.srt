1
00:00:00,500 --> 00:00:09,410
【安静】

2
00:00:09,910 --> 00:00:14,520
>> 欢迎来到第一周的CS50学堂

3
00:00:14,870 --> 00:00:17,050
我先和大家分享一个饼干人的爱情小故事

4
00:00:22,510 --> 00:01:35,950
【音乐】

5
00:01:36,450 --> 00:01:38,720
>> 这是由去年一个学生完成的

6
00:01:38,720 --> 00:01:40,350
一个Scratch项目

7
00:01:40,350 --> 00:01:42,990
让人称赞的是  它不仅很可爱

8
00:01:42,990 --> 00:01:44,990
而且还囊括了所有

9
00:01:44,990 --> 00:01:46,660
我们上周谈到的基本要素

10
00:01:46,660 --> 00:01:48,590
如果你还没有真正沉下心来

11
00:01:48,590 --> 00:01:52,510
看习题集0  网上可以提供这些PDF文件

12
00:01:52,790 --> 00:01:54,840
好好地感受一下像这样的东西

13
00:01:54,840 --> 00:01:56,490
假定只有一分钟左右这么长

14
00:01:56,490 --> 00:01:59,470
先不管它外表看起来是否可爱

15
00:01:59,470 --> 00:02:01,790
也不管它让人无从下手的压迫感

16
00:02:01,790 --> 00:02:03,820
你怎样才能勾勒出

17
00:02:03,820 --> 00:02:04,950
整个故事最初的框架呢?

18
00:02:05,200 --> 00:02:07,750
好吧  让我们先想一下这件事带给我们的主题

19
00:02:07,750 --> 00:02:09,950
编程和解决问题的思想

20
00:02:09,950 --> 00:02:11,760
一台机器最开始只会一步一个脚印

21
00:02:11,760 --> 00:02:14,800
沿着要解决的问题向前迈进

22
00:02:15,020 --> 00:02:17,060
直到最终的结果出来

23
00:02:17,060 --> 00:02:19,720
最后你会发现  你已经解决了一个相当大

24
00:02:19,720 --> 00:02:21,580
相当有趣的问题

25
00:02:21,900 --> 00:02:24,550
而这个问题在最初看起来确是相当复杂的

26
00:02:24,550 --> 00:02:27,560
但是如果你一开始就想一次啃掉整块蛋糕

27
00:02:27,560 --> 00:02:28,810
譬如你一开始就想

28
00:02:28,810 --> 00:02:32,080
完成这个饼干人的爱情故事  你会发现这是行不通的

29
00:02:32,080 --> 00:02:34,600
你可能会制造数不清的bug

30
00:02:34,600 --> 00:02:35,950
对了  我们称bug为错误或

31
00:02:36,190 --> 00:02:38,780
你完全没有预料到的行为  但是它们的确存在

32
00:02:39,120 --> 00:02:43,000
这样看来  你的作品在某种意义上可以说是行为不端

33
00:02:43,240 --> 00:02:46,250
有了这个例子  我想我们可以

34
00:02:46,250 --> 00:02:47,760
考虑一下应该如何下手

35
00:02:47,760 --> 00:02:49,480
解决这样的问题

36
00:02:49,480 --> 00:02:52,190
我先在小窗口里重新播放一下这部片子

37
00:02:52,510 --> 00:02:54,280
我们可以看到许多东西

38
00:02:54,280 --> 00:02:57,370
譬如  很明显我们可以看到有许多小精灵  许多字符

39
00:02:57,590 --> 00:03:00,080
想想上周  每个精灵还自有一套

40
00:03:00,080 --> 00:03:01,810
程序

41
00:03:02,110 --> 00:03:04,120
这些脚本在中间

42
00:03:04,120 --> 00:03:07,120
这些精灵都在右边  当我们选择了某一刻的场景

43
00:03:07,120 --> 00:03:10,290
我们就会看见与整个方案相关联的

44
00:03:10,440 --> 00:03:13,110
脚本  这就是所谓的场景

45
00:03:13,320 --> 00:03:15,400
我们可以让精灵1住在这

46
00:03:15,630 --> 00:03:18,040
然后来看这个特殊的精灵脚本

47
00:03:18,350 --> 00:03:19,560
所以现在让我们真正倒退

48
00:03:19,560 --> 00:03:20,600
返回到开头

49
00:03:21,130 --> 00:03:22,690
刚刚在这发生了很多事情

50
00:03:23,260 --> 00:03:23,890
你准备怎样

51
00:03:23,890 --> 00:03:25,460
完成这些事情呢

52
00:03:25,460 --> 00:03:26,620
说实在的  开头很容易

53
00:03:26,620 --> 00:03:28,850
你第一件要完成的任务

54
00:03:28,850 --> 00:03:31,760
或者说你最起码要做的  是绘出

55
00:03:31,760 --> 00:03:34,250
这个工程里面出现的各式各样的饼干人物图

56
00:03:34,460 --> 00:03:36,740
确保把它们放在合适的位置  我说的对吧?

57
00:03:36,930 --> 00:03:38,650
注意  我们已经有所进展了

58
00:03:38,650 --> 00:03:39,500
虽然这个没起到任何实质性的作用

59
00:03:39,500 --> 00:03:41,540
但是我们朝着我们要解决的问题迈出了一小步

60
00:03:41,830 --> 00:03:43,940
现在  把注意力集中到其中的一个小精灵

61
00:03:43,940 --> 00:03:46,960
比如这个饼干人  男姜饼人

62
00:03:46,960 --> 00:03:48,510
女姜饼人  或者随便任意一个

63
00:03:48,510 --> 00:03:52,230
你想最先研究的饼干人

64
00:03:52,230 --> 00:03:53,890
让它跳舞 跳起来

65
00:03:54,200 --> 00:03:55,540
我所说的"跳舞"是什么意思呢?

66
00:03:55,540 --> 00:03:57,440
就是找出办法让它向左移动一小步

67
00:03:57,850 --> 00:04:00,510
向右移动一小步  向上一小步  向下一小步

68
00:04:00,810 --> 00:04:02,390
像这样不断重复

69
00:04:02,390 --> 00:04:04,160
几分钟或者可能一小时过去后

70
00:04:04,370 --> 00:04:06,720
你颇有希望地拥有至少一个会跳舞的饼干人

71
00:04:06,720 --> 00:04:09,090
可能会没有音乐  也许只是在众多饼干人中间

72
00:04:09,090 --> 00:04:11,300
单纯地跳舞

73
00:04:11,300 --> 00:04:12,690
但是最起码你有一个饼干人模板

74
00:04:12,940 --> 00:04:16,860
可以据此制造出2号饼干人  3号 4号 5号等等

75
00:04:17,060 --> 00:04:18,530
如果你还没有意识到这一点

76
00:04:18,530 --> 00:04:21,060
再想想我们制作出来的一个个在线教程

77
00:04:21,320 --> 00:04:23,370
你可以像复制这些小精灵们一样完成你整个浩瀚的工作

78
00:04:23,370 --> 00:04:24,960
你没有必要一个一个重复地去制作

79
00:04:25,330 --> 00:04:26,550
这样你就可以

80
00:04:26,760 --> 00:04:29,080
启动项目  沿着这条索引  迅速地完成整个计划

81
00:04:29,330 --> 00:04:31,770
下面我们看下一个画面  注意啦

82
00:04:32,600 --> 00:04:34,840
一旦启动  好好地去感受一下

83
00:04:34,840 --> 00:04:36,680
【背景音乐】

84
00:04:36,680 --> 00:04:38,260
>>一旦我们有所改变

85
00:04:38,300 --> 00:04:40,180
下一秒就会发生许多

86
00:04:40,180 --> 00:04:41,060
翻天覆地的变化

87
00:04:41,060 --> 00:04:43,770
刚刚那一刻  那些爱心们从底部上浮到顶部

88
00:04:43,770 --> 00:04:46,540
饼干人则向左向右移动

89
00:04:46,540 --> 00:04:48,710
它们似乎都随着音乐的律动而变化着

90
00:04:48,760 --> 00:04:51,110
也许这是那个制作该动画的同学

91
00:04:51,110 --> 00:04:52,160
不断尝试的结果

92
00:04:52,340 --> 00:04:54,630
但是  你怎样才能让这些爱心们看起来

93
00:04:54,700 --> 00:04:57,480
像是在某种随机的模式下上上下下地移动呢?

94
00:04:57,550 --> 00:05:00,120
好吧  让我们先回想一下上周介绍过的

95
00:05:00,120 --> 00:05:03,630
能产生1~10之间  或者1~100之间随机数的

96
00:05:03,840 --> 00:05:05,800
基本构建块

97
00:05:05,930 --> 00:05:08,030
如果还没意识到这一点  就想想整个事件的关键之处

98
00:05:08,030 --> 00:05:11,320
就好比 让你去寻找一个长方形上相应于某一点的

99
00:05:11,320 --> 00:05:14,360
X坐标和Y坐标  它本质上是格子上的一点

100
00:05:14,360 --> 00:05:17,230
或者类比于像素  只不过这些像素是由上下左右构成

101
00:05:17,230 --> 00:05:19,020
每一点就是一个特定的位置

102
00:05:19,190 --> 00:05:22,470
(X  Y) 如果你想为这些爱心之一选择一个

103
00:05:22,470 --> 00:05:24,430
随机的位置  这样爱心就可以从不同的初始位置开始移动

104
00:05:24,640 --> 00:05:28,750
那么我们就要从1~200或300之间选择一个随机数赋给X

105
00:05:28,750 --> 00:05:32,010
无论舞台有多宽  从适当的调色板中

106
00:05:32,200 --> 00:05:35,010
调出移动板  把爱心放在恰当的位置

107
00:05:35,010 --> 00:05:36,620
然后开始爱心移动

108
00:05:36,750 --> 00:05:39,120
换句话来说  当你开始着手去完成一件属于你自己的工程

109
00:05:39,120 --> 00:05:42,580
或者  从参阅他人现在的作品

110
00:05:42,580 --> 00:05:44,300
更或者是  参考工程设计书中

111
00:05:44,300 --> 00:05:46,320
提到的无数链接

112
00:05:46,740 --> 00:05:49,700
至关重要的一点是  你必须让它工作

113
00:05:49,930 --> 00:05:51,500
然后再继续下一环节

114
00:05:51,560 --> 00:05:53,270
这将是贯穿我们整个课程的

115
00:05:53,330 --> 00:05:54,800
一个亘古不变的主题

116
00:05:54,860 --> 00:05:57,670
如果你只是仅仅干坐着  不费吹灰之力

117
00:05:57,910 --> 00:06:00,130
凭空幻想着我可以把这个项目搞定 你会想地发疯的

118
00:06:00,130 --> 00:06:02,830
也许你会写出一点东西出来  可能会有一点点错误

119
00:06:02,900 --> 00:06:05,550
紧接着这或那又出现一点小错误

120
00:06:05,550 --> 00:06:07,560
这些小错误一点一点地堆积了起来

121
00:06:07,720 --> 00:06:09,890
直到你开始运行你整个项目

122
00:06:10,130 --> 00:06:11,380
你会发现这堆东西根本就不工作

123
00:06:11,380 --> 00:06:12,740
这时就出现你

124
00:06:12,740 --> 00:06:14,130
不知道如何下手的局面

125
00:06:14,350 --> 00:06:17,100
说实在的  这堂课在编程方面最棒的策略之一

126
00:06:17,100 --> 00:06:21,090
简而言之  就是--设计

127
00:06:21,090 --> 00:06:23,770
但这只是一些让事情更简单

128
00:06:23,990 --> 00:06:27,680
更容易的小技巧

129
00:06:27,680 --> 00:06:30,190
让你专注于问题的核心关键

130
00:06:30,190 --> 00:06:32,130
而不是一些可能让你绊倒的

131
00:06:32,130 --> 00:06:33,890
这样或那样的小错误

132
00:06:33,890 --> 00:06:35,740
我希望  如果你们还没带着这种心态

133
00:06:35,740 --> 00:06:37,210
着手处理习题集0

134
00:06:37,430 --> 00:06:39,150
那么一小步一小步地走

135
00:06:39,150 --> 00:06:41,910
从这样一个个单独的小零件  一步步地

136
00:06:41,910 --> 00:06:45,300
搭建出你瑰丽无比的高楼大厦

137
00:06:45,450 --> 00:06:49,680
如此说来  我们有时候会喜欢用Google搜索

138
00:06:49,920 --> 00:06:53,850
然后我们发现昨晚在CS50的其他课程上提到的FlyBy

139
00:06:53,850 --> 00:06:56,880
在最后一分钟的购物清单里

140
00:06:56,880 --> 00:06:59,240
也就是说  对于你们中第一次加入我们的同学而言

141
00:06:59,240 --> 00:07:01,140
是相当不错的

142
00:07:01,370 --> 00:07:02,580
没有任何东西是本来就应该存在的

143
00:07:02,580 --> 00:07:05,010
那些课程也是直到星期五才出来  上周的两堂课

144
00:07:05,010 --> 00:07:06,840
都可以在cs50 net找到

145
00:07:07,180 --> 00:07:08,120
我真的不知道如何

146
00:07:08,120 --> 00:07:11,280
解释这儿的口号

147
00:07:11,520 --> 00:07:13,960
如果你想追根究底  我也不能

148
00:07:13,960 --> 00:07:15,670
在这里做一个主题演讲  它说

149
00:07:15,750 --> 00:07:17,940
"这是最后一分钟购物  特价商品大甩卖"

150
00:07:18,490 --> 00:07:20,660
虽然我也不清楚有什么外卖

151
00:07:20,660 --> 00:07:23,670
但是你必须意识到商家是很欢迎您光临他的店铺的

152
00:07:23,670 --> 00:07:24,950
而且希望你以后也一直光顾

153
00:07:25,170 --> 00:07:26,920
如果你上我们的课程只是要一个分数

154
00:07:26,920 --> 00:07:28,560
那么我只需要在你的白卡片上签个名就可以了

155
00:07:28,560 --> 00:07:30,260
或者说  如果在第五周的周一前还没考虑好

156
00:07:30,480 --> 00:07:32,320
把你的解聘书拿来 只要我签个字

157
00:07:32,380 --> 00:07:34,310
任何时候你都开以离开我的教室

158
00:07:34,390 --> 00:07:37,160
当然  如果你有任何问题和疑虑

159
00:07:37,210 --> 00:07:39,470
我也很高心和大家做课下交流

160
00:07:39,740 --> 00:07:41,880
那么迄今为止  最重要的是什么呢?

161
00:07:41,880 --> 00:07:42,840
我还没有分文别类

162
00:07:42,840 --> 00:07:44,450
这周五  我们会正式开始

163
00:07:44,450 --> 00:07:47,220
更多细节  尽在本周五

164
00:07:47,220 --> 00:07:49,410
好了  课堂时间宝贵  我们就不多说废话了

165
00:07:49,410 --> 00:07:53,250
因为我们之中至少有60个人神游太虚

166
00:07:53,250 --> 00:07:54,570
在想Cabot 和 Quincy 食堂

167
00:07:54,570 --> 00:07:56,530
有哪些菜了吧

168
00:07:56,600 --> 00:07:59,880
注意前面  看黑板  把心思收回来

169
00:07:59,880 --> 00:08:01,750
虽然开学之初

170
00:08:01,750 --> 00:08:04,990
大家心思涣散  这无可厚非

171
00:08:05,230 --> 00:08:07,830
但是我要提醒大家去cs50 net网站看看

172
00:08:07,830 --> 00:08:09,460
这里清清楚楚告诉你

173
00:08:09,460 --> 00:08:11,500
什么时候该学习工作  当然也包括今晚的明天的

174
00:08:11,850 --> 00:08:14,420
我们还有一个机会供

175
00:08:14,810 --> 00:08:17,360
一个与研究生助教或课程辅导员交流的机会

176
00:08:17,360 --> 00:08:19,760
更直白来说

177
00:08:19,760 --> 00:08:21,590
是提供你们开小差的机会

178
00:08:21,870 --> 00:08:23,750
看看你们周围哪些人

179
00:08:23,750 --> 00:08:24,900
在开小差呢

180
00:08:25,210 --> 00:08:29,140
在即将到来的礼拜天  下周一 二

181
00:08:29,140 --> 00:08:30,800
我们将开设一些"超级课程"

182
00:08:30,910 --> 00:08:33,990
CS50学堂主要在每周的周末 周一和周二开设

183
00:08:34,240 --> 00:08:37,120
我们不需要你很死板  用大约一周的时间来上课

184
00:08:37,470 --> 00:08:40,740
而是很随意

185
00:08:40,740 --> 00:08:41,990
只需要你每周末 周一和周二来就可以了

186
00:08:42,100 --> 00:08:44,910
相应的日程表也可以在网上看的到

187
00:08:45,220 --> 00:08:46,830
这些"超级课程"之所以"超级"

188
00:08:46,830 --> 00:08:48,190
是因为它们是知识的精华部分

189
00:08:48,190 --> 00:08:50,490
只要你乐意  上哪堂课都可以

190
00:08:50,490 --> 00:08:52,900
这些课程不仅覆盖了本周的学习内容

191
00:08:52,900 --> 00:08:55,950
也可能囊括了

192
00:08:55,950 --> 00:08:59,020
下周要学习的知识

193
00:08:59,020 --> 00:09:01,890
请大家把注意力集中到我们的第二本习题集--习题集1上

194
00:09:01,960 --> 00:09:05,100
这周末会以PDF格式发布出来

195
00:09:05,100 --> 00:09:08,130
所以请意识到支撑结构(课程安排)已经出来了 并且正在进行

196
00:09:08,170 --> 00:09:11,340
如果需要帮助  如果在课堂时间有任何不懂的问题

197
00:09:11,340 --> 00:09:13,380
请在help@cs50 net上面给我

198
00:09:13,540 --> 00:09:14,150
留言

199
00:09:14,590 --> 00:09:17,720
我们上周非常简略地提到了Scratch

200
00:09:17,720 --> 00:09:19,730
不过我希望你们热切的投入了进去了

201
00:09:19,730 --> 00:09:21,770
那个界面是相当直观的

202
00:09:21,920 --> 00:09:24,070
相信我  这真的可以让你实现你

203
00:09:24,070 --> 00:09:25,590
大脑中的构想

204
00:09:25,770 --> 00:09:26,940
好吧  让我们回归正题

205
00:09:26,940 --> 00:09:29,440
今天我要讲的是一种传统的编程语言

206
00:09:29,440 --> 00:09:32,040
更确切地说  是一种比较低级的编程语言

207
00:09:32,370 --> 00:09:34,800
它的编程思想和我们

208
00:09:34,800 --> 00:09:36,950
上周学的颇为相似  也许你在较早的课程中

209
00:09:36,950 --> 00:09:39,350
已经见识过  但是我们今天要谈论的

210
00:09:39,350 --> 00:09:44,100
是我们上周提到的

211
00:09:44,490 --> 00:09:46,210
等价的编程思想

212
00:09:46,260 --> 00:09:47,630
也是我们这周要谈论的主题

213
00:09:47,630 --> 00:09:50,210
可能你在屏幕上 编程中见识到的

214
00:09:50,210 --> 00:09:53,330
语法 字符看起来非常晦涩难懂

215
00:09:53,330 --> 00:09:56,350
甚至可以说是丑陋  像什么分号啊

216
00:09:56,350 --> 00:09:58,920
括号啊等等  还有一些难七八糟的语法

217
00:09:59,160 --> 00:10:00,090
但是到了最后  你会发现

218
00:10:00,090 --> 00:10:02,620
这些都不过是一些人为约定而已

219
00:10:02,720 --> 00:10:04,970
而蕴含在里面的编程思想跟这个例子并无二致

220
00:10:05,040 --> 00:10:08,140
>> 我们先看看这个例子  "点击绿旗"下面显示"

221
00:10:08,140 --> 00:10:12,140
这也许是我们用Scratch软件写出的最简单的 程序了

222
00:10:12,350 --> 00:10:15,010
这只是某种"hello world"程序

223
00:10:15,250 --> 00:10:17,670
即计算机界最简单的程序样例

224
00:10:17,830 --> 00:10:20,400
如果用今天的C语言写出来

225
00:10:20,860 --> 00:10:22,880
就是屏幕上这样

226
00:10:23,060 --> 00:10:25,670
第一眼扫过去  是不是有点神秘

227
00:10:25,670 --> 00:10:28,140
有点繁琐  还有一些莫名其妙的大括号

228
00:10:28,140 --> 00:10:29,710
分号和引号呢

229
00:10:29,990 --> 00:10:33,110
但是如果你抛开所有这些繁琐的细节  把注意力集中到

230
00:10:33,110 --> 00:10:37,610
它的编程思想  那么它只不过一个蓝色的say程序块

231
00:10:37,700 --> 00:10:39,640
是一个声明

232
00:10:39,640 --> 00:10:42,190
即所谓的printf函数  其中的f是

233
00:10:42,230 --> 00:10:43,410
用于格式化输出

234
00:10:43,680 --> 00:10:46,770
这些你想输出到屏幕上的字符串啊 语句啊

235
00:10:46,770 --> 00:10:48,460
单词啊  或者你事先

236
00:10:48,460 --> 00:10:50,570
在白色输入框中敲进去的内容

237
00:10:50,760 --> 00:10:52,670
现在你们需要用键盘做同样的事情

238
00:10:52,670 --> 00:10:53,840
但是你们要写在

239
00:10:53,840 --> 00:10:55,850
双引号之间

240
00:10:55,850 --> 00:10:57,480
你会很快适应这些

241
00:10:57,480 --> 00:10:59,880
微小的区别

242
00:11:00,060 --> 00:11:02,150
但我们正是要把这些罗里吧嗦的语法细节

243
00:11:02,150 --> 00:11:04,450
尤其是那些让人非常头大的句子啃下来才行

244
00:11:04,450 --> 00:11:07,580
因为如果我们一旦遗漏掉某个符号

245
00:11:07,580 --> 00:11:08,780
譬如一个分号

246
00:11:08,780 --> 00:11:10,860
从另一方面看来  很有可能什么都工作不了

247
00:11:11,090 --> 00:11:14,430
正是因为用该语言写出来这些

248
00:11:14,730 --> 00:11:15,960
粗糙的设计理念 纷繁的细节

249
00:11:15,960 --> 00:11:18,060
才有了我们今天看到的众多

250
00:11:18,060 --> 00:11:19,860
形形色色 简洁大方的

251
00:11:19,860 --> 00:11:20,970
编程语言

252
00:11:21,200 --> 00:11:23,680
大家看  这里的"oh  hi world"

253
00:11:23,680 --> 00:11:26,840
是不是正好对应于这一条语句呢

254
00:11:26,840 --> 00:11:28,740
那么其他的成分又是对应于什么呢?

255
00:11:28,740 --> 00:11:30,660
首先我要简单介绍一下"循环"这个概念

256
00:11:30,860 --> 00:11:32,260
这是你们经常要用到的东西

257
00:11:32,260 --> 00:11:35,030
很明显在饼干人爱情故事里面

258
00:11:35,030 --> 00:11:35,560
就有用到循环

259
00:11:35,560 --> 00:11:37,790
这些饼干人来来回回的移动

260
00:11:37,790 --> 00:11:40,390
还有这些爱心们上上下下地漂浮

261
00:11:40,390 --> 00:11:42,800
都用到我们上周提到过的循环结构

262
00:11:42,990 --> 00:11:45,580
当然还有个声明在里面  就有点像屏幕上

263
00:11:45,630 --> 00:11:46,600
显示的这样

264
00:11:47,220 --> 00:11:51,330
即while语句  幸好该语言的创始人

265
00:11:51,330 --> 00:11:54,590
选择的术语都很通俗易懂

266
00:11:54,590 --> 00:11:57,550
让人只通过字面意思就能联想到其真正含义

267
00:11:57,890 --> 00:12:00,070
所以在这里我们可以把条件写死

268
00:12:00,420 --> 00:12:03,200
也就是我们上周提到过的  故意让循环条件

269
00:12:03,200 --> 00:12:03,700
一直为真

270
00:12:05,140 --> 00:12:08,850
因此而出现死循环

271
00:12:08,850 --> 00:12:10,810
屏幕上的这些语句无论怎么运行

272
00:12:10,810 --> 00:12:12,360
都无法改变它为真的事实

273
00:12:12,610 --> 00:12:14,760
这就是所谓的死循环

274
00:12:15,020 --> 00:12:17,910
无论你想不想要

275
00:12:17,910 --> 00:12:19,400
屏幕上都会不断打印出"hi"

276
00:12:19,680 --> 00:12:22,170
同理  大家回想一下上个星期

277
00:12:22,170 --> 00:12:25,080
在Scratch软件中  循环结构都用黄色标记出来了

278
00:12:25,080 --> 00:12:27,000
与此类似

279
00:12:27,180 --> 00:12:30,010
在C语言和一些类似的编程语言中

280
00:12:30,010 --> 00:12:31,510
你也必须搭建同样的架构

281
00:12:31,510 --> 00:12:33,740
同样也得注意前大括号啊

282
00:12:34,050 --> 00:12:36,550
后大括号啊等等这些细节问题

283
00:12:36,820 --> 00:12:38,450
在上个星期

284
00:12:39,020 --> 00:12:40,510
在你们的工程里面  可能会看到所谓的

285
00:12:40,510 --> 00:12:41,200
"重复循环"

286
00:12:41,510 --> 00:12:42,180
同理

287
00:12:42,430 --> 00:12:44,880
但又不同于"无限循环"

288
00:12:45,100 --> 00:12:47,890
你可以根据需要

289
00:12:47,890 --> 00:12:48,900
为它指定循环次数

290
00:12:48,900 --> 00:12:50,630
比如这里我任意选一个"10"

291
00:12:50,910 --> 00:12:52,540
你怎样实现你的需求呢?

292
00:12:52,790 --> 00:12:55,480
在C语言和一些我们这学期将要接触的编程语言中

293
00:12:55,700 --> 00:12:57,140
你将会用到所谓的for循环

294
00:12:57,390 --> 00:12:59,590
也许作为一种语法规则  它看起来不是那么的通俗易懂

295
00:12:59,590 --> 00:13:00,910
但是你一旦知道曲中奥妙

296
00:13:00,910 --> 00:13:03,060
就不难理解了

297
00:13:03,060 --> 00:13:05,910
对于以下定义

298
00:13:06,170 --> 00:13:08,410
你将会在实际的代码中看到一对圆括号

299
00:13:08,410 --> 00:13:12,300
比如  我们让int i=0

300
00:13:12,560 --> 00:13:15,230
大家都知道int代表整数类型  一个数字而已

301
00:13:15,230 --> 00:13:17,900
i只是一个int型的变量

302
00:13:17,900 --> 00:13:19,360
可以用于计数

303
00:13:19,360 --> 00:13:21,020
但又不必关心其名字的一个变量

304
00:13:21,350 --> 00:13:23,540
其中的分号只是用来间隔两条语句

305
00:13:23,840 --> 00:13:27,180
i小于10代表"只要i小于10  你就可以

306
00:13:27,180 --> 00:13:28,500
执行以下语句"

307
00:13:28,500 --> 00:13:31,910
然后是最右边的i++  我们上周在socks例子的伪代码中

308
00:13:31,910 --> 00:13:35,020
曾经见到过  不是么?只是代表i加1而已

309
00:13:35,280 --> 00:13:38,030
如此看来  这个长篇故事经过这个奇异的语法规则

310
00:13:38,030 --> 00:13:40,420
简化后就立马简单明朗了许多

311
00:13:40,560 --> 00:13:42,250
只需要重复做10次就OK了

312
00:13:42,540 --> 00:13:44,390
但是我们是要在电脑的低平台上编程不是吗?

313
00:13:44,390 --> 00:13:47,040
那我们就要像我上周提到过的那样

314
00:13:47,270 --> 00:13:49,970
一定要小心 小心 再小心地

315
00:13:49,970 --> 00:13:52,850
操纵这台又聋又哑的机器

316
00:13:52,850 --> 00:13:54,140
它只会根据你敲进去的

317
00:13:54,140 --> 00:13:56,280
特定指令来做事

318
00:13:56,550 --> 00:13:58,630
所以我们必须使用非常精细的语法

319
00:13:58,850 --> 00:14:02,010
而不是模模糊糊  让人费解的概念

320
00:14:02,180 --> 00:14:03,320
那么变量呢?

321
00:14:03,320 --> 00:14:05,180
大家看一下左边的这一段代码

322
00:14:05,180 --> 00:14:08,100
其中有一个随便定义的变量counter  counter=0

323
00:14:08,100 --> 00:14:11,550
它会一直显示counter的值

324
00:14:11,770 --> 00:14:13,500
每显示一次  counter加1

325
00:14:13,680 --> 00:14:15,090
用C语言表示就是counter++

326
00:14:15,090 --> 00:14:17,510
那么像Scratch那样的代码

327
00:14:17,510 --> 00:14:18,580
长啥样子呢?

328
00:14:18,800 --> 00:14:20,750
当然  你可以有好几种方法来实现这一目标

329
00:14:20,750 --> 00:14:22,500
但是其中一种方法

330
00:14:22,500 --> 00:14:26,420
只需要用到我们刚刚看到的那种语法  int counter=0

331
00:14:26,640 --> 00:14:28,850
首先要定义一个名为counter的

332
00:14:28,850 --> 00:14:30,060
变量

333
00:14:30,300 --> 00:14:32,720
因为需要是整数  所以我们把它定义为int类型

334
00:14:32,920 --> 00:14:34,100
并初始化为0

335
00:14:34,310 --> 00:14:36,330
然后再借用先前的代码

336
00:14:36,330 --> 00:14:38,880
做一个永久性的循环  即while(true)循环

337
00:14:38,880 --> 00:14:40,310
紧接着需要用到一个

338
00:14:40,310 --> 00:14:41,720
之前我们看到过的printf函数

339
00:14:41,720 --> 00:14:43,440
只需要一个counter++

340
00:14:43,810 --> 00:14:45,250
所有的准备工作都做好了

341
00:14:45,250 --> 00:14:47,710
从一方面来看  其中蕴含的编程思想是相当简单的

342
00:14:47,820 --> 00:14:50,890
但从另一方面来看  相同中又有那么一丝不同

343
00:14:51,140 --> 00:14:53,280
我们接着要讲的是"布尔表达式"

344
00:14:53,310 --> 00:14:56,120
它是用来判断真假的

345
00:14:56,330 --> 00:14:59,030
其实我们已经在之前的循环表达式中见识过了

346
00:14:59,300 --> 00:15:01,090
但是在Scratch语言里  我必须得问这么一个问题:

347
00:15:01,090 --> 00:15:06,800
x小于y或x小于y  y小于z

348
00:15:06,800 --> 00:15:09,170
你可以把这些表达式结合

349
00:15:09,220 --> 00:15:12,030
成一个表达式  即屏幕所示

350
00:15:12,270 --> 00:15:14,410
语法规则其实很相似

351
00:15:14,580 --> 00:15:16,890
只需要把绿色版块换成一对圆括号就可以了

352
00:15:17,140 --> 00:15:19,210
"小于"侧还是用的"小于"

353
00:15:19,420 --> 00:15:22,360
而中间的"and"将去掉

354
00:15:22,430 --> 00:15:25,660
换成两个紧挨着的&符号  但至于为什么是&&而不是&

355
00:15:25,660 --> 00:15:27,370
我们以后会提到

356
00:15:27,370 --> 00:15:29,130
但这只是就变化部分而言

357
00:15:29,360 --> 00:15:32,000
而在实际应用中  看到左边的Bool表达式

358
00:15:32,340 --> 00:15:37,130
如果(if) x小于y  就说"x小于y"  或者(else)

359
00:15:37,360 --> 00:15:39,750
(if) x >y  就说

360
00:15:39,750 --> 00:15:43,320
"x大于y"  再或者(else) "x等于y"

361
00:15:43,320 --> 00:15:44,790
看  非常简单吧

362
00:15:44,840 --> 00:15:47,810
天晓得为啥我们关心x和y的值

363
00:15:47,810 --> 00:15:49,280
在这里我们只是断章取义(截取了一部分代码)罢了

364
00:15:49,540 --> 00:15:51,950
如果把它转换成C语言

365
00:15:52,190 --> 00:15:55,060
你又会看到一些大括号啊 if啊 圆括号啊等等

366
00:15:55,290 --> 00:15:56,610
我们只是借助

367
00:15:56,610 --> 00:15:59,070
之前学过的语法规则

368
00:15:59,260 --> 00:16:02,190
所以才能容易转换

369
00:16:02,190 --> 00:16:03,150
一通百通

370
00:16:03,150 --> 00:16:06,800
最后  我需要你们回想一下之前玩过的一个游戏--

371
00:16:06,800 --> 00:16:10,530
"Fruit-craft RPG"  我们只需要让那个小人

372
00:16:10,530 --> 00:16:13,090
上上下下 左左右右地移动  收集桔子啊 苹果啊等等

373
00:16:13,090 --> 00:16:14,580
然后把它们送到仓库里去

374
00:16:14,830 --> 00:16:16,680
那个程序很有趣

375
00:16:16,680 --> 00:16:20,160
它有一个用Scratch做出来的清单

376
00:16:20,160 --> 00:16:22,320
还有一个貌似容器的列表

377
00:16:22,320 --> 00:16:24,350
你可以不断往里面加东西

378
00:16:24,540 --> 00:16:27,040
C语言里面也有同样类似于列表的东西

379
00:16:27,380 --> 00:16:28,390
我们称之为"数组"

380
00:16:28,610 --> 00:16:30,790
它们并不像Scratch里的"清单"

381
00:16:30,790 --> 00:16:33,810
那么的多功能化

382
00:16:33,810 --> 00:16:36,020
当你向数组里面添加东西或者从中取出东西时

383
00:16:36,050 --> 00:16:38,590
要非常非常的小心

384
00:16:38,850 --> 00:16:41,720
就好比Scratch里面橘色的这一块

385
00:16:41,800 --> 00:16:44,920
把"桔子"加到所谓的"清单"里面去

386
00:16:44,920 --> 00:16:46,620
在C语言中至少需要两行代码来实现

387
00:16:46,830 --> 00:16:49,910
第一行代码创建一个货单数组

388
00:16:50,140 --> 00:16:53,210
第二行就需要把"桔子"放进去

389
00:16:53,210 --> 00:16:55,940
但是最终  我们课件上讨论的主题

390
00:16:55,940 --> 00:16:59,410
并不是让你现在就写一个C语言的程序

391
00:16:59,410 --> 00:17:01,790
而是要告诉大家不要你被那些分号括号

392
00:17:01,790 --> 00:17:04,480
还有一些从未见过的符号等一些细节搅得心烦意乱

393
00:17:04,480 --> 00:17:07,790
因为它们本质上

394
00:17:07,890 --> 00:17:09,780
和我们上周用Scratch做出来的游戏

395
00:17:10,070 --> 00:17:11,410
并无区别

396
00:17:11,530 --> 00:17:13,610
所以说  放轻松点  别紧张

397
00:17:13,610 --> 00:17:16,170
让我们回到这个最简单的程序

398
00:17:16,310 --> 00:17:20,210
你们也许觉得啼笑皆非  这么简单的例子

399
00:17:20,210 --> 00:17:23,320
用C语言写出来就可以了嘛  的确只需要几行代码

400
00:17:23,320 --> 00:17:24,870
就可以让这个程序跑起来

401
00:17:24,870 --> 00:17:27,140
就像上周五的那样  我之所以没让它跑起来

402
00:17:27,140 --> 00:17:29,140
因为编程步骤之一

403
00:17:29,140 --> 00:17:31,740
就是"写"

404
00:17:31,950 --> 00:17:34,360
用指定的编程语言

405
00:17:34,360 --> 00:17:35,510
写出所谓的源代码

406
00:17:35,850 --> 00:17:38,910
上周我们写了一个socks程序  但那只是伪代码

407
00:17:38,910 --> 00:17:41,230
并不是真正的编程语言

408
00:17:41,230 --> 00:17:43,380
好比某种"伪英语"  或"类C语言"

409
00:17:43,380 --> 00:17:44,430
你现在在语法中看到的就是所谓的伪代码

410
00:17:44,820 --> 00:17:46,360
非常随意

411
00:17:46,590 --> 00:17:49,070
现在  我和大家一起写C语言代码

412
00:17:49,320 --> 00:17:52,700
但我不指望写出来后就能跑起来

413
00:17:52,700 --> 00:17:55,870
至关重要的一步  我将在本周五跟大家细细道来

414
00:17:55,870 --> 00:17:57,850
如果我很嚣张地失败了怎么办?

415
00:17:57,920 --> 00:18:00,160
>>好吧  我已经做错了很多事情了

416
00:18:00,160 --> 00:18:01,480
我们需要一个编译器

417
00:18:01,660 --> 00:18:04,270
在一个名为GCC的黑色小窗口里

418
00:18:04,270 --> 00:18:05,320
运行我们的程序

419
00:18:05,320 --> 00:18:07,190
然后得出想要的结果

420
00:18:07,460 --> 00:18:09,100
这就是所谓的编译器

421
00:18:09,320 --> 00:18:11,090
用这种语言写一个至少需要

422
00:18:11,090 --> 00:18:13,050
两步完成的小程序

423
00:18:13,050 --> 00:18:15,620
比如你们写出像这样的源代码后

424
00:18:15,620 --> 00:18:18,530
保存  你将会得到一个文本文件

425
00:18:18,730 --> 00:18:21,350
但这个文件并不是以XX txt命名

426
00:18:21,600 --> 00:18:23,870
而是以XX c命名  这只是一种约定而已

427
00:18:24,160 --> 00:18:26,280
但是仅仅这样是不够的  计算机

428
00:18:26,280 --> 00:18:29,050
最终只会认识0和1

429
00:18:29,050 --> 00:18:31,750
你现在得到的 c的文件显然不是0 1的合集

430
00:18:31,890 --> 00:18:34,720
所以你必须把源代码

431
00:18:34,860 --> 00:18:37,780
即C语言代码转换成二进制文件

432
00:18:37,780 --> 00:18:40,960
这个过程就需要我们提到的编译器了

433
00:18:40,960 --> 00:18:43,720
它是由别人编写的一个软件  以这些代码作为输入

434
00:18:43,720 --> 00:18:45,920
将会产生(屏幕所示)的输出

435
00:18:46,130 --> 00:18:49,260
也就是一些0啊 1啊  请大家注意

436
00:18:49,260 --> 00:18:51,910
这些数字每8个挨一块  这就是所谓的字节

437
00:18:52,250 --> 00:18:54,940
实际CPU能够处理的东西

438
00:18:54,940 --> 00:18:57,150
过一段时间  我们会知晓它们的模式是什么

439
00:18:57,150 --> 00:19:00,380
为什么它们这么做 它们都做了哪些事情

440
00:19:00,550 --> 00:19:02,060
而对于你们中想要在计算机科学

441
00:19:02,060 --> 00:19:04,850
方面有所发展的人  将会遇到一个非常有趣的领域

442
00:19:04,850 --> 00:19:07,190
在那个世界里  会有许多像网络世界 硬件界

443
00:19:07,190 --> 00:19:08,940
这样或那样的小细节

444
00:19:09,120 --> 00:19:12,660
但又往往是这些小细节才解决了许多真实世界里的问题

445
00:19:12,660 --> 00:19:15,980
照这么说来  我们应该开始写第一个程序了

446
00:19:16,220 --> 00:19:19,020
也许我不应该说它是个两步完成的程序

447
00:19:19,020 --> 00:19:21,200
准确来讲  应该是三步  前两步--写

448
00:19:21,380 --> 00:19:23,160
第三步--运行

449
00:19:23,220 --> 00:19:24,490
好吧  我们开始吧

450
00:19:24,910 --> 00:19:27,230
怎么写呢?

451
00:19:27,230 --> 00:19:30,670
问题是你如何在大多数电脑上编程?

452
00:19:30,960 --> 00:19:35,610
譬如  我有一台"Apple Mac"但是你必须在

453
00:19:35,610 --> 00:19:37,590
Windows操作系统 Linux操作系统上编程

454
00:19:37,860 --> 00:19:40,210
如果你安装了一台编译器

455
00:19:40,210 --> 00:19:42,730
在Macintosh下编程就相当容易了

456
00:19:42,730 --> 00:19:43,870
你可以登录Apple网站

457
00:19:43,870 --> 00:19:45,080
下载相应链接

458
00:19:45,390 --> 00:19:48,320
在PC机上有点复杂  但是它是免费的

459
00:19:48,320 --> 00:19:49,460
你一般下载的软件

460
00:19:49,690 --> 00:19:52,360
类似Linux的操作系统等等通常都需要

461
00:19:52,360 --> 00:19:54,540
一个编译器  或者你可以运行一些简单的指令来获取

462
00:19:54,790 --> 00:19:57,040
我们长话短说  即使你们到现在还没有完全了解

463
00:19:57,040 --> 00:19:59,640
你们中有笔记本的 台式机的人

464
00:19:59,970 --> 00:20:02,980
现在也应该编写程序了

465
00:20:03,190 --> 00:20:03,940
我承认这很枯燥

466
00:20:04,650 --> 00:20:05,970
>> 这次我非常有先见之明地

467
00:20:05,970 --> 00:20:08,250
安装了这个编译器  但是我这次要做的却是

468
00:20:08,250 --> 00:20:10,020
运行名为"Nano"的指令

469
00:20:10,380 --> 00:20:11,960
这是一个非常简单的程序

470
00:20:12,240 --> 00:20:14,210
本质上  它跟Mac里的"Text Edit"

471
00:20:14,210 --> 00:20:16,580
和pc机里面的"Notepad"很相似

472
00:20:16,690 --> 00:20:20,410
我先给我的文件命名为"hello c"

473
00:20:20,410 --> 00:20:23,320
你们也许会觉得有点烦  因为不是GUI--

474
00:20:23,320 --> 00:20:25,830
图形用户界面  这是CLI

475
00:20:26,230 --> 00:20:27,700
命令行界面

476
00:20:27,990 --> 00:20:30,110
这意味着没有窗口  没有图标

477
00:20:30,110 --> 00:20:31,780
这是一个真正的基于文本的界面

478
00:20:32,100 --> 00:20:33,720
我们要入乡随俗  习惯这样的界面

479
00:20:33,750 --> 00:20:36,610
因为这是你们将要用到的程序  不是为习题集0  而是

480
00:20:36,980 --> 00:20:39,960
而是为习题集1开始写程序的

481
00:20:40,050 --> 00:20:42,110
注意窗口顶部  这是用来提醒你  你工作在何种环境

482
00:20:42,110 --> 00:20:44,970
左上角告诉你你当前使用的是何种程序

483
00:20:45,190 --> 00:20:47,080
最有趣的部分在底部

484
00:20:47,080 --> 00:20:49,080
这里大多数命令你们都用不着

485
00:20:49,290 --> 00:20:51,560
这个小插入符意味着控制

486
00:20:51,770 --> 00:20:54,750
每个键盘都有一个控制键

487
00:20:55,090 --> 00:20:57,440
譬如  当你敲入X时  就退出这个程序

488
00:20:57,880 --> 00:21:01,880
按住control O键来写程序

489
00:21:01,880 --> 00:21:04,120
我也不明白为什么不用S代表"保存"而是用"写出"

490
00:21:04,120 --> 00:21:05,320
"写出"也就是"保存"啦

491
00:21:05,570 --> 00:21:07,600
坦白说  你们只需要知道

492
00:21:07,600 --> 00:21:09,290
这些东西就可以了

493
00:21:09,510 --> 00:21:11,750
现在我们在脑子里再过一遍这个程序

494
00:21:11,750 --> 00:21:12,830
我在幻灯片上最先看到的

495
00:21:12,830 --> 00:21:15,680
是标准头文件#include《stdio h》

496
00:21:16,110 --> 00:21:19,350
然后是int main  圆括号和大括号

497
00:21:19,350 --> 00:21:25,210
紧接着是printf"Oh hi world!"

498
00:21:25,210 --> 00:21:28,810
由于某些必要原因  我们还得加上\n  后引号

499
00:21:28,810 --> 00:21:31,340
圆括号 分号 后大括号

500
00:21:31,620 --> 00:21:33,810
好吧  这个程序也许太平庸了  让人印象不够深刻

501
00:21:33,810 --> 00:21:36,060
我们也知道这个程序是干嘛的

502
00:21:36,060 --> 00:21:38,420
在我们开始更有意思的事情之前

503
00:21:38,420 --> 00:21:40,310
让我们再来讨论一下整个过程后再回来

504
00:21:40,680 --> 00:21:42,360
这些语法细节到底是在做什么呢?

505
00:21:42,360 --> 00:21:44,520
先给你们一点小小的提示

506
00:21:44,820 --> 00:21:48,440
敲入控制键X  它会很罗嗦地

507
00:21:48,480 --> 00:21:51,260
问你是否保存所做的修改

508
00:21:51,260 --> 00:21:52,100
如果回答为NO  就不保存修改过的部分

509
00:21:52,130 --> 00:21:54,290
这大家都懂的吧  所以敲入Y  也就是保存

510
00:21:54,880 --> 00:21:57,010
紧接着又出现  文件名:hello c

511
00:21:57,010 --> 00:21:58,960
也就是问你  要不要改文件名

512
00:21:58,960 --> 00:22:00,430
我们只需要敲入回车键  不管它就可以了

513
00:22:00,680 --> 00:22:01,910
我们又立刻回到刚刚的界面

514
00:22:02,160 --> 00:22:04,620
一般来说  如果你在命令行界面

515
00:22:04,720 --> 00:22:07,330
没有收到错误信息  那就是好消息

516
00:22:07,460 --> 00:22:10,670
没有消息就是好消息

517
00:22:10,970 --> 00:22:12,570
也就是说我们现在安全返回

518
00:22:12,570 --> 00:22:14,730
说明一切正常

519
00:22:14,730 --> 00:22:20,190
现在我输入这条命令:GCC hello c

520
00:22:20,450 --> 00:22:23,190
这代表运行hello c这个程序

521
00:22:23,190 --> 00:22:25,130
是由"Apple"或其他人编写的  名为GCC

522
00:22:25,130 --> 00:22:28,910
以hello c为输入  生成一个

523
00:22:28,910 --> 00:22:31,760
a out输出文件

524
00:22:33,410 --> 00:22:34,060
什么事都没发生

525
00:22:34,320 --> 00:22:35,710
为啥?说明运行正常呗

526
00:22:35,710 --> 00:22:37,370
意味着生成了某种文件

527
00:22:37,370 --> 00:22:39,440
至于为什么叫a out?

528
00:22:39,510 --> 00:22:42,470
约定而已

529
00:22:42,470 --> 00:22:44,830
为什么?也许是因为out代表是输出吧

530
00:22:44,830 --> 00:22:46,530
而a则是字母表的第一个吧

531
00:22:46,530 --> 00:22:47,730
它也就这么点创造性

532
00:22:48,100 --> 00:22:50,580
现在我输入 /

533
00:22:50,580 --> 00:22:52,030
你们将会看到一些小戏法

534
00:22:52,290 --> 00:22:54,500
程序默认保存在

535
00:22:54,500 --> 00:22:56,790
当前目录下的文件夹

536
00:22:57,050 --> 00:23:00,720
/意味着运行这个名为"a out"的文件

537
00:23:00,720 --> 00:23:03,270
是我当前目录下的文件

538
00:23:03,270 --> 00:23:05,220
而不是应用程序文件夹或其他别的地方的a out

539
00:23:05,520 --> 00:23:07,470
好  我要点回车了  瞧!

540
00:23:07,470 --> 00:23:08,730
我看到了  "oh  hi world"

541
00:23:09,010 --> 00:23:10,470
这究竟是怎么工作的呢?

542
00:23:10,470 --> 00:23:11,650
在转去介绍

543
00:23:11,650 --> 00:23:12,940
其他更实际有趣的知识前

544
00:23:12,940 --> 00:23:15,310
我先让大家注意一个小细节

545
00:23:15,520 --> 00:23:18,120
大家看到前面第一行

546
00:23:18,280 --> 00:23:22,320
#include  后面包含一些其他人写的

547
00:23:22,600 --> 00:23:23,660
源代码

548
00:23:24,040 --> 00:23:26,980
就是这些你在本文件中看不到的一些代码

549
00:23:26,980 --> 00:23:29,710
实现了将首字母a

550
00:23:29,710 --> 00:23:31,610
放在屏幕的左上角

551
00:23:31,610 --> 00:23:33,820
然后把其他字母加在其右边

552
00:23:34,060 --> 00:23:36,210
我想当然地认为

553
00:23:36,460 --> 00:23:39,980
我的电脑知道如何打印相应信息到屏幕上

554
00:23:39,980 --> 00:23:41,480
但是事情往往不是你们想的那样

555
00:23:41,610 --> 00:23:43,910
需要有人去实现

556
00:23:43,910 --> 00:23:49,710
这个printf函数

557
00:23:49,710 --> 00:23:51,630
以双引号间的信息为输入

558
00:23:51,630 --> 00:23:53,690
输出相应字母到屏幕上

559
00:23:53,920 --> 00:23:56,410
那么  我们怎样才能用别人写的代码呢?

560
00:23:56,530 --> 00:23:59,740
好吧  我需要包含一个头文件

561
00:23:59,980 --> 00:24:03,930
在这里的头文件称为标准输入输出文件(standard I/O)或stdio h

562
00:24:04,160 --> 00:24:06,870
这是由某位前人编写的文本文件

563
00:24:06,870 --> 00:24:09,230
我们只需要刚才所述的一行代码

564
00:24:09,230 --> 00:24:12,090
就能告诉电脑  让我连接到

565
00:24:12,090 --> 00:24:14,430
这个前人在那个文件中写的代码

566
00:24:14,500 --> 00:24:15,370
那这个头文件里究竟有什么呢?

567
00:24:15,370 --> 00:24:17,310
恐怕整个教室就我一个人关心

568
00:24:17,310 --> 00:24:20,170
这个printf函数吧

569
00:24:20,500 --> 00:24:22,630
从此以后  我将在我的程序里把这些工具

570
00:24:22,850 --> 00:24:25,750
称为我们可以用来写代码的组件

571
00:24:25,750 --> 00:24:28,770
在我自己的程序中  我们将了解到它被叫做为一个函数

572
00:24:29,040 --> 00:24:31,290
这儿还有一些其他的玩意  比如  int  我们再接着讲

573
00:24:31,470 --> 00:24:33,990
Main可以说是很切题的  因为你在Scratch里开始

574
00:24:33,990 --> 00:24:36,940
写程序时  你会用什么模块作为入口点呢?

575
00:24:36,940 --> 00:24:38,270
【听不清】

576
00:24:38,270 --> 00:24:40,160
>> 是的  "点击绿旗"

577
00:24:40,160 --> 00:24:41,610
就是用这种直白的方式告诉你

578
00:24:41,820 --> 00:24:44,430
你需要点击这个绿旗才能启动整个程序

579
00:24:44,670 --> 00:24:46,550
这是程序生效的入口

580
00:24:46,670 --> 00:24:49,120
而在C语言里面  与之相应的部分就是main

581
00:24:49,170 --> 00:24:52,070
也就是当下我们输入的main()

582
00:24:52,290 --> 00:24:54,860
不久之后  你们就可以看到  我们是可以在括号里面加参数的

583
00:24:54,860 --> 00:24:57,580
这些参数可以让你的程序更有用

584
00:24:57,850 --> 00:24:59,650
而大括号就好比

585
00:24:59,650 --> 00:25:01,920
Scratch里面的联锁机制

586
00:25:02,130 --> 00:25:04,040
我们在之前的for循环中已经见识过

587
00:25:04,340 --> 00:25:07,430
至于这个名曰main的函数

588
00:25:07,750 --> 00:25:11,270
由我们自己写的函数  也是一个工具

589
00:25:11,270 --> 00:25:12,460
只不过由我们自己编写

590
00:25:12,460 --> 00:25:14,450
而不是像printf那样已经由前人写好了

591
00:25:14,630 --> 00:25:16,510
我们必须要说明main在哪开始  在哪结束

592
00:25:16,690 --> 00:25:18,660
这样我们就要用到大括号了

593
00:25:18,710 --> 00:25:21,690
所有在大括号里面的代码都由我们自己编写

594
00:25:21,960 --> 00:25:23,300
最后  我都写了些什么代码呢?

595
00:25:23,300 --> 00:25:25,570
看到这一行代码

596
00:25:25,820 --> 00:25:28,590
现在你们应该知道语法是用来干嘛的吧

597
00:25:28,590 --> 00:25:30,890
双引号代表在这里填上想要输入的东西

598
00:25:31,070 --> 00:25:33,180
这也是你们在Scratch的白色输入框里要填入的东西

599
00:25:33,480 --> 00:25:34,940
也许已经有人知道

600
00:25:34,940 --> 00:25:37,620
反斜杠n代表某种简写方式吧?

601
00:25:37,620 --> 00:25:38,510
【听不清】

602
00:25:38,510 --> 00:25:40,010
>>没错  就是换行符

603
00:25:40,010 --> 00:25:42,530
如果你把它分开

604
00:25:42,530 --> 00:25:44,660
那么电脑会逐字逐句地解析

605
00:25:44,840 --> 00:25:46,640
你拆开写的代码

606
00:25:46,640 --> 00:25:48,710
由此得到的结果一般都是错误的

607
00:25:48,710 --> 00:25:52,370
即使这样看起来和你

608
00:25:52,370 --> 00:25:54,890
想要的输出"Oh   hi world"没啥两样

609
00:25:54,890 --> 00:25:57,130
仅仅只是把其他代码往下挤了一行

610
00:25:57,430 --> 00:26:00,100
一切都改变了  而且这样写出的代码可读性也不高

611
00:26:00,160 --> 00:26:02,530
你可以想象一下  这有很多行代码

612
00:26:02,530 --> 00:26:03,720
突然一个后引号

613
00:26:03,720 --> 00:26:05,150
移到下一行最左边

614
00:26:05,150 --> 00:26:06,750
是不是很丑呢

615
00:26:06,750 --> 00:26:09,030
如果东丢一点  西落一点

616
00:26:09,030 --> 00:26:11,120
你很快就会不爽了

617
00:26:11,320 --> 00:26:14,440
一旦代码稍微复杂点

618
00:26:14,440 --> 00:26:16,680
而你又不规范你的代码

619
00:26:16,680 --> 00:26:18,000
那么你想找什么东西就很困难了

620
00:26:18,000 --> 00:26:20,410
幸亏我们有一些类似反斜杠n的转义字符

621
00:26:20,450 --> 00:26:23,190
这只是一种简化方式

622
00:26:23,190 --> 00:26:26,600
用来告知电脑要在这新添一行

623
00:26:26,600 --> 00:26:28,360
我们先保存再继续

624
00:26:28,360 --> 00:26:30,420
概而述之  我们总共走了三步

625
00:26:30,420 --> 00:26:33,230
首先  Nano hello c

626
00:26:33,550 --> 00:26:36,120
第二  GCC hello c把它编译成01二进制文件

627
00:26:36,330 --> 00:26:38,560
第三  运行

628
00:26:38,950 --> 00:26:42,130
我承认  对于程序来说  a out是个很雷人的名字  不是吗?

629
00:26:42,130 --> 00:26:44,330
如果Microsoft Apple等公司

630
00:26:44,330 --> 00:26:45,890
推出来的程序都默认命名为a out

631
00:26:45,890 --> 00:26:47,040
估计全世界都要崩溃了

632
00:26:47,360 --> 00:26:48,690
你们就无法区别各个程序了

633
00:26:48,980 --> 00:26:51,780
当然这个世界也有一些其他的程序名字

634
00:26:51,950 --> 00:26:53,770
这样的话  你们将如何GCC它们呢?

635
00:26:53,770 --> 00:26:57,130
你们可以为它们指定开关或标志

636
00:26:57,800 --> 00:27:00,050
一般而言  当你运行命令行程序时

637
00:27:00,320 --> 00:27:02,540
可以把把这些当做输入

638
00:27:02,540 --> 00:27:04,730
像什么参数啊 或开关啊 或标志啊等等

639
00:27:04,910 --> 00:27:06,560
当然有很多同义词啦

640
00:27:06,560 --> 00:27:08,070
刚开始是很难理解这些词的

641
00:27:08,320 --> 00:27:10,040
但其实都是一个意思

642
00:27:10,320 --> 00:27:13,690
所以  只要在命令行上为这个程序

643
00:27:13,860 --> 00:27:15,860
再添加一个名曰GCC的输入就OK啦

644
00:27:15,860 --> 00:27:16,970
你将会在第一个版本GCC hello c

645
00:27:16,970 --> 00:27:18,620
和第二个版本GCC -o hello hello c之间

646
00:27:19,020 --> 00:27:21,680
看到两点相似之处

647
00:27:21,720 --> 00:27:25,300
很显然我们在第二个版本的第二行添加了一些东西

648
00:27:25,300 --> 00:27:26,790
【听不清】

649
00:27:26,790 --> 00:27:28,280
>>对  就是-o hello

650
00:27:28,280 --> 00:27:32,280
我主观认为  -o 代表输出

651
00:27:32,430 --> 00:27:34,480
那么会输出什么呢?

652
00:27:34,730 --> 00:27:37,740
输出将为hello out而不是默认的a out

653
00:27:37,970 --> 00:27:41,290
我们可以试一下  回到开头  运行GCC

654
00:27:41,580 --> 00:27:44,430
hello c  不对  应该把光标一到前面

655
00:27:44,430 --> 00:27:45,900
添上-o

656
00:27:45,900 --> 00:27:48,680
大小写是很重要的  然后是hello

657
00:27:48,920 --> 00:27:51,680
点回车  我就可以 /

658
00:27:51,680 --> 00:27:54,700
也就是运行我默认位置处的hello程序

659
00:27:54,700 --> 00:27:58,010
而不是硬盘上其他某个位置的  hello  回车

660
00:27:58,010 --> 00:27:59,320
还是那个hello程序

661
00:27:59,320 --> 00:28:01,830
更有意思了  但我们很快就会发现

662
00:28:01,830 --> 00:28:05,140
并不是所有的编译都

663
00:28:05,140 --> 00:28:06,230
像这条命令这么简单

664
00:28:06,510 --> 00:28:10,960
我们用到的命令行变得日趋复杂

665
00:28:11,240 --> 00:28:14,010
就是寻找一种能在大多数系统上运行的更快捷的方式  哇!

666
00:28:14,070 --> 00:28:17,060
也就是说  你有一个hello c的文件

667
00:28:17,300 --> 00:28:19,930
你想把它变成一个名为hello的程序

668
00:28:19,930 --> 00:28:22,860
那么只需要敲入命令make hello

669
00:28:22,860 --> 00:28:24,260
它就会自动为你生成

670
00:28:24,260 --> 00:28:25,780
一个hello程序

671
00:28:26,010 --> 00:28:27,800
我们将会看到这和我们的程序一样

672
00:28:27,800 --> 00:28:30,830
变得越来越有趣了

673
00:28:31,130 --> 00:28:34,470
照这么说来  你在哪运行这些

674
00:28:34,470 --> 00:28:36,520
程序呢?

675
00:28:36,520 --> 00:28:38,040
我会在我的Mac机上展示给大家看

676
00:28:38,090 --> 00:28:39,470
你也许有一台Mac机  也有可能是一台PC机

677
00:28:39,470 --> 00:28:42,450
Linux  无所谓  无论是何种型号

678
00:28:42,450 --> 00:28:45,160
噩梦即将来临

679
00:28:45,160 --> 00:28:47,310
因为每个人的电脑都或多或少有些不同的配置

680
00:28:47,310 --> 00:28:48,920
所以很难说会出现什么情况

681
00:28:49,080 --> 00:28:50,560
你们不能

682
00:28:50,560 --> 00:28:53,270
用同一台机器  除非你们自己按照一系列

683
00:28:53,270 --> 00:28:54,990
冗长的步骤手工配置

684
00:28:55,240 --> 00:28:57,500
你们自己的电脑

685
00:28:57,500 --> 00:29:00,930
那么  在编程界和工业界普遍

686
00:29:00,930 --> 00:29:03,460
使用的一个解决方案是

687
00:29:03,460 --> 00:29:06,450
不在你自己的电脑上写程序

688
00:29:06,650 --> 00:29:08,840
而是在服务器上编程运行

689
00:29:08,840 --> 00:29:11,100
服务器上的软件都是标准化的

690
00:29:11,260 --> 00:29:12,330
而且可以通过网络访问

691
00:29:12,330 --> 00:29:15,600
所以无论何时何地都能访问

692
00:29:15,600 --> 00:29:18,690
你们也可以访问这些工具啊 软件啊 还有一些

693
00:29:18,910 --> 00:29:20,360
授权访问的小诀窍

694
00:29:20,670 --> 00:29:24,710
所以你在习题集0或习题集1上看到的

695
00:29:24,710 --> 00:29:28,960
访问"CS50云"

696
00:29:29,020 --> 00:29:32,350
就是一些校园服务器

697
00:29:32,350 --> 00:29:34,660
你可以注册一个用户名和密码

698
00:29:34,660 --> 00:29:37,610
默认情况下  这个用户名可以和你的

699
00:29:37,610 --> 00:29:41,300
FAS账户名一样  因为FAS也有自己独立的系统

700
00:29:41,300 --> 00:29:43,670
你可以用这些用户名+密码登陆

701
00:29:43,670 --> 00:29:44,830
到实验室网站上和一些其他地方

702
00:29:45,020 --> 00:29:46,590
如果大家觉得难的话

703
00:29:46,590 --> 00:29:49,170
习题集1上有一些说明  教你如何

704
00:29:49,170 --> 00:29:51,210
激活你的云账户

705
00:29:51,210 --> 00:29:53,630
因为你们只有在CS50云上才能编写程序

706
00:29:53,630 --> 00:29:56,310
编译 检测

707
00:29:56,310 --> 00:29:57,920
并最终运行

708
00:29:58,150 --> 00:29:59,700
如果我们快进到本课程末  你们会发现

709
00:29:59,700 --> 00:30:02,610
尽管有一些难点  CS50课堂的大多数学生

710
00:30:02,610 --> 00:30:06,330
更愿意自己主持他们的毕业设计

711
00:30:06,330 --> 00:30:08,640
如果你们的毕设是有真正域名的网站

712
00:30:08,680 --> 00:30:11,050
譬如isawyouharvard com 或其他

713
00:30:11,110 --> 00:30:14,600
或shuttleboy com或任何你可以找的到的名字

714
00:30:14,600 --> 00:30:17,930
只需9 99美元  你们就可以买的到想要的域名

715
00:30:18,250 --> 00:30:20,730
>> 这个秋天  我们就可以做想要做的东西了

716
00:30:20,730 --> 00:30:22,660
因为所有的代码都集中加载在

717
00:30:22,660 --> 00:30:26,030
我们称之为"云"的集群系统上  决定好了么? 可能大多数人

718
00:30:26,030 --> 00:30:27,710
为了好玩  或者为了创业

719
00:30:27,710 --> 00:30:30,400
更倾向于买你们自己的域名

720
00:30:30,400 --> 00:30:33,080
让你们的域名和我们的服务器关联上很容易的

721
00:30:33,270 --> 00:30:35,390
那样的话  尽管服务器域名为

722
00:30:35,390 --> 00:30:38,720
cloud cs50 net  但是你的用户 朋友

723
00:30:38,720 --> 00:30:42,650
家人还是可以访问isawyouharvard com

724
00:30:42,840 --> 00:30:45,780
因特网知道isawyouhavard com

725
00:30:45,780 --> 00:30:48,210
或者说你的域名位于这里

726
00:30:48,210 --> 00:30:51,900
这是我们能为你们的毕业设计所做的

727
00:30:51,900 --> 00:30:54,390
一点点人文关怀

728
00:30:54,480 --> 00:30:56,700
如果你们想做一些基于网站的东西

729
00:30:56,700 --> 00:30:58,710
而且不愿意别人插手

730
00:30:59,340 --> 00:31:02,730
也行  好吧  那我们接着上课  讲些更有趣的东西

731
00:31:02,730 --> 00:31:05,270
不再一遍又一遍重复令人作呕的hello

732
00:31:05,270 --> 00:31:06,830
那么  我接下来要介绍的是

733
00:31:06,940 --> 00:31:08,070
是一个必不可少 至关重要的工具

734
00:31:08,070 --> 00:31:09,840
对  就是函数

735
00:31:09,840 --> 00:31:12,010
它是一个迷你程序  你可以自己写

736
00:31:12,070 --> 00:31:13,460
也可以调用别人的程序

737
00:31:13,490 --> 00:31:15,490
在C语言里  第一个需要我们自己写的函数就是

738
00:31:15,590 --> 00:31:17,630
main函数

739
00:31:17,630 --> 00:31:19,170
就好比是  每一个Scratch工程

740
00:31:19,170 --> 00:31:22,900
都是由"点击绿旗"开始的

741
00:31:22,900 --> 00:31:24,070
我们所有的程序都起始于这个main函数

742
00:31:24,420 --> 00:31:26,520
标准库函数--第一行代码

743
00:31:26,520 --> 00:31:31,370
严格来说  不是每次都要写的  但是一旦你调用某个别人写

744
00:31:31,500 --> 00:31:34,520
的函数  而这个函数又恰巧位于标准库里面

745
00:31:34,520 --> 00:31:37,780
你就要像我们看到的这样  把它include进去

746
00:31:37,780 --> 00:31:39,810
如果你没有include这个库函数  GCC的时候

747
00:31:39,810 --> 00:31:41,200
编译器就会报错

748
00:31:41,200 --> 00:31:43,810
我们将会看到数不清的错误信息

749
00:31:43,810 --> 00:31:46,080
当你在家里做习题集的时候

750
00:31:46,080 --> 00:31:48,020
这也是学习的一种方式

751
00:31:48,020 --> 00:31:49,730
一种非常有用的反馈机制

752
00:31:50,130 --> 00:31:54,190
C语言其实是比较原始 比较低级的

753
00:31:54,370 --> 00:31:56,820
让它随便做件事都很困难

754
00:31:56,820 --> 00:31:58,990
你们中上了AP计算机科学这门课

755
00:31:58,990 --> 00:32:00,760
或者类似的课程的人可能还记得

756
00:32:00,760 --> 00:32:02,820
即使只是从用户那里得到一个输入

757
00:32:02,820 --> 00:32:05,350
也相当麻烦

758
00:32:05,350 --> 00:32:07,330
你需要写许多代码

759
00:32:07,330 --> 00:32:08,870
你要学会使用扫描仪

760
00:32:08,870 --> 00:32:11,430
你要百依百顺才能从用户那里得到一个输入

761
00:32:11,430 --> 00:32:13,290
这个输入可能只是一个

762
00:32:13,290 --> 00:32:14,660
语言优先级

763
00:32:14,660 --> 00:32:16,850
那我们这学期初要做些什么呢?

764
00:32:16,850 --> 00:32:18,980
经过一些必要的训练

765
00:32:18,980 --> 00:32:20,610
让我们迅速褪去无知  变得更加充实

766
00:32:20,920 --> 00:32:23,090
我们会提供自己的库

767
00:32:23,320 --> 00:32:27,160
当然不是标准输入输出库(stdio h)了  而是叫做cs50 h

768
00:32:27,160 --> 00:32:29,880
这里面有一些我们写的代码

769
00:32:29,880 --> 00:32:32,570
等一下我会举几个例子

770
00:32:32,570 --> 00:32:34,890
我们写了一些函数

771
00:32:35,140 --> 00:32:37,660
比如GetChar  意思是得到一个变量

772
00:32:37,660 --> 00:32:40,430
如果你想得到一个单独的字母  用GetDouble

773
00:32:40,480 --> 00:32:42,230
这只是一种数据类型  不久后我们就会看到

774
00:32:42,270 --> 00:32:43,200
还有GetFloating--

775
00:32:43,210 --> 00:32:44,650
得到一个浮点型的数据  并赋给一个浮点型的指针

776
00:32:44,650 --> 00:32:46,820
GetInt   GetLonglong

777
00:32:46,820 --> 00:32:48,620
过一会我们就知道多出来的那一部分意味着什么了

778
00:32:48,620 --> 00:32:51,650
还有GetString 最后一个用处最大

779
00:32:51,810 --> 00:32:54,150
我先举几个例子

780
00:32:54,180 --> 00:32:56,680
现在我要离开我自己的电脑Mac

781
00:32:56,680 --> 00:32:58,090
去标准环境

782
00:32:58,130 --> 00:33:01,820
连接到所谓的"云"上

783
00:33:01,820 --> 00:33:04,120
方法是一条命令行程序  或GUI程序

784
00:33:04,540 --> 00:33:07,290
借助习题集上的在线指导

785
00:33:07,290 --> 00:33:08,180
你们就知道怎么做了

786
00:33:08,460 --> 00:33:11,000
在Mac上运行一个Terminal程序

787
00:33:11,280 --> 00:33:12,890
默认情况下所有的Mac电脑都装有该程序

788
00:33:12,890 --> 00:33:14,970
PC用户就用免费的Putty软件

789
00:33:15,030 --> 00:33:18,060
或者secureCRT  在Harvard可以下载到

790
00:33:18,060 --> 00:33:19,930
再回到习题集1

791
00:33:20,330 --> 00:33:22,440
运行这条命令:SSH

792
00:33:22,530 --> 00:33:25,080
即Secure Shell

793
00:33:25,080 --> 00:33:26,750
这样就加密连接到

794
00:33:26,750 --> 00:33:27,920
某个人的服务器上

795
00:33:28,210 --> 00:33:32,210
Malan@cloud cs50 net  回车

796
00:33:32,530 --> 00:33:33,990
现在需要我输入密码

797
00:33:34,250 --> 00:33:38,170
我们会很快看到一个提示  表明我是谁

798
00:33:38,240 --> 00:33:39,300
我在哪

799
00:33:39,360 --> 00:33:40,890
圆括号里的东西

800
00:33:40,890 --> 00:33:42,880
告诉我们  我们现在正处于哪个目录下

801
00:33:43,220 --> 00:33:45,630
好  我们继续  写一个颇为有趣的

802
00:33:45,630 --> 00:33:46,780
程序

803
00:33:46,780 --> 00:33:48,000
在你们打印出来的所有资料中

804
00:33:48,230 --> 00:33:50,180
我最不屑于打印这些幻灯片了

805
00:33:50,180 --> 00:33:51,270
它们都相当抽象

806
00:33:51,470 --> 00:33:53,030
我一般会打印源代码

807
00:33:53,030 --> 00:33:54,400
你们可以做笔记  但是没有必要

808
00:33:54,400 --> 00:33:56,590
把屏幕上所有的东西都记下来

809
00:33:57,160 --> 00:33:59,370
你们看到的所有的文件或程序

810
00:33:59,370 --> 00:34:01,400
都会在这里按字母表顺序一一列出

811
00:34:01,400 --> 00:34:05,280
如果没看到hello c

812
00:34:05,410 --> 00:34:08,010
那就是hi1 c

813
00:34:08,010 --> 00:34:09,090
我们再回到这里

814
00:34:09,640 --> 00:34:14,760
hi2 c  实际上我只改变了一点点

815
00:34:15,250 --> 00:34:17,430
我再给大家变一个小戏法

816
00:34:17,430 --> 00:34:19,090
今天我们不用Nano

817
00:34:19,090 --> 00:34:20,580
而是用Vim

818
00:34:20,900 --> 00:34:22,590
另外一个文本编辑器

819
00:34:22,590 --> 00:34:25,640
与其说是文本编辑器  还不如说是一个文字处理软件

820
00:34:26,030 --> 00:34:27,670
打开你们的资料

821
00:34:27,670 --> 00:34:30,330
hi2 c  首先

822
00:34:30,540 --> 00:34:31,990
有几行代码

823
00:34:31,990 --> 00:34:34,810
顶部有一大堆封装好的东西

824
00:34:34,810 --> 00:34:36,980
看起来很丑  因为我们的字体设置的很大

825
00:34:37,270 --> 00:34:38,880
我们先剔除这些细节

826
00:34:39,240 --> 00:34:41,380
当你用这样那样的语言写程序时

827
00:34:41,380 --> 00:34:43,910
为了便于自己或他人

828
00:34:44,140 --> 00:34:46,540
阅读我们写的代码  我们必须得做一些注解

829
00:34:46,540 --> 00:34:48,960
这就是所谓的注释

830
00:34:48,960 --> 00:34:51,240
在左上角  大家可以看到/

831
00:34:51,500 --> 00:34:53,940
这是用来告诉大家  所有跟在它后面的

832
00:34:54,110 --> 00:34:55,900
标记都只是注释而已

833
00:34:55,900 --> 00:34:58,280
它们最后不会转换成0和1

834
00:34:58,490 --> 00:34:59,490
只是方便大家阅读而已

835
00:34:59,760 --> 00:35:02,280
事实上大家可以看到  这有颗星  这有颗星

836
00:35:02,280 --> 00:35:04,710
这有颗星  其实是我手痒

837
00:35:04,710 --> 00:35:06,760
这看起来像是用*围成个框  把它们包围起来

838
00:35:06,760 --> 00:35:08,060
其实这是完全没有必要的

839
00:35:08,060 --> 00:35:10,680
我们唯一要关注的是这里的/

840
00:35:10,970 --> 00:35:13,190
还有底部的*/

841
00:35:13,190 --> 00:35:14,250
所有这些都是注释

842
00:35:14,250 --> 00:35:16,930
现在我们要向下滚动到这里  这才是我们要关心的问题

843
00:35:17,210 --> 00:35:18,970
说句题外话  你们中有一些

844
00:35:18,970 --> 00:35:20,530
看起来聚精会神  实际上开小差的同学

845
00:35:20,680 --> 00:35:22,550
也许我还不能对号入座

846
00:35:22,550 --> 00:35:26,440
但这些人必须意识到  我会一笔带过

847
00:35:26,470 --> 00:35:27,720
一些你们可能不懂的问题

848
00:35:27,720 --> 00:35:30,310
今天这堂课纯粹是帮助那些平时爱玩的同学

849
00:35:30,600 --> 00:35:33,420
好  我们再回到这些代码

850
00:35:33,420 --> 00:35:36,330
我现在放大一点  大家会看到1

851
00:35:36,330 --> 00:35:41,510
2 3 4 5 6 7 8 9行代码  多亏了空格

852
00:35:41,510 --> 00:35:42,790
这些代码才能看起来如此美观

853
00:35:43,110 --> 00:35:44,070
接着呢?

854
00:35:44,070 --> 00:35:47,290
第一行代码  我用紫色标记

855
00:35:47,290 --> 00:35:48,710
这样增加了可读性

856
00:35:48,960 --> 00:35:52,670
这里写在include cs50 h

857
00:35:52,810 --> 00:35:56,580
众所周知  cs50 h是由CS50的员工

858
00:35:56,850 --> 00:35:58,620
编写的一个库文件

859
00:35:59,000 --> 00:36:02,770
接着的一行代码写着include stdio h

860
00:36:02,800 --> 00:36:05,050
这个库文件包含一些我们常用的函数

861
00:36:05,050 --> 00:36:06,420
譬如 printf函数

862
00:36:06,800 --> 00:36:09,430
所以说  printf并不是我们所看到的那个样子

863
00:36:09,840 --> 00:36:13,370
这些头文件是以 h为后缀的  完全不同于

864
00:36:13,370 --> 00:36:14,320
一个 c文件

865
00:36:14,580 --> 00:36:16,610
在头文件里

866
00:36:16,610 --> 00:36:17,960
只有一些函数名

867
00:36:18,140 --> 00:36:20,160
在C文件里面却是真正的

868
00:36:20,160 --> 00:36:21,960
代码

869
00:36:22,190 --> 00:36:24,780
你们自己写的程序只需要包括

870
00:36:24,780 --> 00:36:25,520
头文件就可以了

871
00:36:25,520 --> 00:36:27,260
cs50 h 和standard io h是什么

872
00:36:28,090 --> 00:36:30,450
大家该知道了吧

873
00:36:30,450 --> 00:36:31,700
稍后我会带来更多细节

874
00:36:31,950 --> 00:36:34,050
现在  大家要记住

875
00:36:34,050 --> 00:36:36,160
先写int再写main

876
00:36:36,420 --> 00:36:38,170
前括号

877
00:36:38,170 --> 00:36:40,210
后括号  前大括号

878
00:36:40,610 --> 00:36:43,670
把这些规定的东西写好后

879
00:36:43,670 --> 00:36:45,060
我们才能写真正的程序

880
00:36:45,370 --> 00:36:47,000
大家可以看到  这个程序和之前的

881
00:36:47,000 --> 00:36:49,660
颇有不同  不再是单纯地

882
00:36:50,360 --> 00:36:53,700
它可能会显示"oh  hi David "

883
00:36:53,700 --> 00:36:55,980
这一部分的确很无趣  但是这是怎么做到的呢?

884
00:36:55,980 --> 00:36:57,040
注意一些细节

885
00:36:57,040 --> 00:36:58,750
我们可以更灵活地运用之前的一些

886
00:36:58,750 --> 00:36:59,820
构建程序块

887
00:37:00,180 --> 00:37:03,900
在前面的幻灯片  我有提到过一些数据类型

888
00:37:03,900 --> 00:37:05,280
像int(整数类型)

889
00:37:05,480 --> 00:37:07,050
int型数据也就这么点用处

890
00:37:07,050 --> 00:37:09,470
更多的时候  我们要用到一些单词 字符

891
00:37:09,470 --> 00:37:11,970
回想一下期中的时候  我们讨论过密码学

892
00:37:11,970 --> 00:37:14,260
和一些不规则信息

893
00:37:14,260 --> 00:37:16,400
我们需要话语来表达自己  而不是数字

894
00:37:16,610 --> 00:37:17,760
其实我们已经有了

895
00:37:18,090 --> 00:37:22,630
当我们要表示单词啊 词组啊 句子啊等等这样的东西时

896
00:37:22,630 --> 00:37:25,550
就会用到字符串  它们位于双引号之间

897
00:37:25,640 --> 00:37:27,130
也就是这里双引号之间的David

898
00:37:27,130 --> 00:37:29,680
是双引号  不是单引号哦

899
00:37:30,120 --> 00:37:33,140
左边的string name=

900
00:37:33,230 --> 00:37:36,490
先等等  我们称之为name

901
00:37:36,490 --> 00:37:38,110
一般是根据系统命名法

902
00:37:38,730 --> 00:37:40,030
只不过一个变量而已  不是么?

903
00:37:40,030 --> 00:37:42,580
你也可以把它命名为X  Y  Z

904
00:37:42,620 --> 00:37:45,370
如果我们基于本义来命名  它就是一个name(名字)

905
00:37:45,820 --> 00:37:48,080
即  变量的名字就是name

906
00:37:48,280 --> 00:37:50,010
那么  这个变量的类型是什么?

907
00:37:50,010 --> 00:37:53,050
很不幸  在C语言里  给变量赋值之前

908
00:37:53,050 --> 00:37:54,810
你必须搞清楚它的数据类型

909
00:37:55,070 --> 00:37:56,640
先不管我之前提到的int

910
00:37:56,890 --> 00:37:59,260
如果你想把一个字符串赋给某个变量

911
00:37:59,300 --> 00:38:01,980
那你必须事先声明这个变量是string类型的

912
00:38:02,240 --> 00:38:05,780
再回到这里  我有一个名为name的变量

913
00:38:06,090 --> 00:38:09,660
而且把字符串David赋给了name变量

914
00:38:09,910 --> 00:38:11,780
我要这变量干什么呢?

915
00:38:11,780 --> 00:38:15,200
这里printf中的f是用于格式化输出的

916
00:38:15,540 --> 00:38:18,430
在printf的双引号之间写死一个

917
00:38:18,430 --> 00:38:19,740
字符串之前

918
00:38:20,050 --> 00:38:21,740
这次  我还是做同样的事情  但是不同的是

919
00:38:21,930 --> 00:38:23,870
请大家把注意力集中到这

920
00:38:24,140 --> 00:38:25,940
有一个%s符号

921
00:38:26,230 --> 00:38:28,190
这就是所谓的字符串格式

922
00:38:28,240 --> 00:38:31,290
它只是一个占位符  告诉电脑

923
00:38:31,290 --> 00:38:33,660
我想在这放一个东西  但是暂时还不知道放什么东西

924
00:38:33,660 --> 00:38:35,110
我先打断一下

925
00:38:35,360 --> 00:38:37,810
在这个逗号后面

926
00:38:38,130 --> 00:38:41,050
注意反斜杠n(换行)后面加上后引号

927
00:38:41,290 --> 00:38:42,670
后引号

928
00:38:42,880 --> 00:38:45,050
再右边就是逗号  name

929
00:38:45,350 --> 00:38:48,900
我们在使用printf函数时

930
00:38:48,900 --> 00:38:51,390
先放进去一个输入  之后的输入我们就要

931
00:38:51,540 --> 00:38:53,100
调用参数了

932
00:38:53,140 --> 00:38:54,630
圆括号里面的东西

933
00:38:54,840 --> 00:38:56,080
只是一个函数的输入

934
00:38:56,360 --> 00:38:58,790
有时候我们可以往圆括号里填入多个参数

935
00:38:58,790 --> 00:39:01,050
参数与参数之间用逗号分开

936
00:39:01,250 --> 00:39:02,690
那如果我想填入一个不确定的名字呢?

937
00:39:02,970 --> 00:39:05,710
大家可以凭直觉猜测一下

938
00:39:05,930 --> 00:39:07,430
%s就是这个占位符

939
00:39:07,680 --> 00:39:09,400
为我要填入的名字占位

940
00:39:09,640 --> 00:39:12,100
基于这是某人多年以前写的程序

941
00:39:12,100 --> 00:39:15,520
最终的结果是打印出这个  这个

942
00:39:15,780 --> 00:39:19,320
在格式化字符串中间的David

943
00:39:19,320 --> 00:39:21,270
然后返回结果

944
00:39:21,620 --> 00:39:23,770
退出这个程序  我们继续

945
00:39:24,570 --> 00:39:30,780
继续运行  大家还记得怎么编译吗?

946
00:39:31,230 --> 00:39:32,790
GCC hi2 c  回车

947
00:39:32,790 --> 00:39:34,070
好像工作了

948
00:39:34,070 --> 00:39:36,240
/a out  回车  出现了  "oh  hi David"

949
00:39:36,450 --> 00:39:37,820
好吧  我们再加深点

950
00:39:37,820 --> 00:39:38,450
难度

951
00:39:38,450 --> 00:39:42,710
再创建一个文件hi3 c  还是一样  头部有一些注释信息

952
00:39:42,710 --> 00:39:44,980
大家要养成一个良好的编程习惯

953
00:39:44,980 --> 00:39:47,120
这是本课程另一个重要的中心思想

954
00:39:47,120 --> 00:39:49,780
我会在本周五还有以后的课堂时间着重强调这个问题

955
00:39:50,110 --> 00:39:52,190
用简明扼要的语言

956
00:39:52,190 --> 00:39:54,610
描述你的程序

957
00:39:54,870 --> 00:39:56,160
是一种很好的编程风格

958
00:39:56,160 --> 00:39:58,230
你们自己写程序时就会发现

959
00:39:58,230 --> 00:40:01,730
用40行甚至400行代码来代替繁杂拥挤的4行代码

960
00:40:01,730 --> 00:40:04,360
将会让事情简化许多

961
00:40:04,360 --> 00:40:07,070
你会发现  即使由于某些原因

962
00:40:07,070 --> 00:40:09,150
你不知道如何写代码

963
00:40:09,150 --> 00:40:12,350
先写些注释  于人于己  都是好事

964
00:40:12,350 --> 00:40:13,970
易于理解嘛

965
00:40:14,540 --> 00:40:17,470
>> 现在我们可以再多一点交互

966
00:40:17,530 --> 00:40:20,660
马上  我们能接近scratch的关键了

967
00:40:20,660 --> 00:40:22,500
即从用户那里获取输入

968
00:40:22,500 --> 00:40:23,760
这可不是绘画

969
00:40:24,030 --> 00:40:26,090
我们至少不是在硬编码程序

970
00:40:26,350 --> 00:40:28,060
那是没有趣味的

971
00:40:28,060 --> 00:40:28,710
好吧  我们开始吧

972
00:40:28,970 --> 00:40:30,660
开头还是一样

973
00:40:30,660 --> 00:40:33,120
包括我们自己的库  包括标准输入输出库

974
00:40:33,410 --> 00:40:35,540
然后是main函数

975
00:40:35,780 --> 00:40:36,850
紧接着我们要干嘛?

976
00:40:36,850 --> 00:40:38,830
我们这次可能会不止一次调用printf函数

977
00:40:38,880 --> 00:40:41,070
如果我想说点什么  做点什么

978
00:40:41,290 --> 00:40:43,770
再说点什么  我就得调用printf两次

979
00:40:44,150 --> 00:40:45,630
注意啦  我要printf啦

980
00:40:45,630 --> 00:40:48,680
首先是state your name  冒号  空格

981
00:40:48,680 --> 00:40:50,930
基于美学等原因

982
00:40:50,930 --> 00:40:51,900
我们就不换行了

983
00:40:51,900 --> 00:40:53,490
让将要打印出的东西跟在其后

984
00:40:53,920 --> 00:40:55,060
如果我们不是打印别人已经写好的东西

985
00:40:55,360 --> 00:40:58,050
那么就要调用这个函数了

986
00:40:58,050 --> 00:41:00,580
同样  它也位于标准库  也就是我曾经提到过的

987
00:41:00,580 --> 00:41:03,530
GetString   在CS50库里面

988
00:41:03,530 --> 00:41:05,960
这是服务器在最开始几周

989
00:41:05,960 --> 00:41:09,590
提供给你们的又一个封装好的函数

990
00:41:09,590 --> 00:41:12,930
让其更直观化  机制化

991
00:41:13,190 --> 00:41:14,560
我们来看一下会发生什么

992
00:41:14,560 --> 00:41:17,410
printf的任务是把一些东西打印

993
00:41:17,410 --> 00:41:18,770
到屏幕上

994
00:41:19,160 --> 00:41:21,840
照这么说来  GetString按字面意思解释

995
00:41:21,840 --> 00:41:23,760
就是--从用户那里获取一些东西

996
00:41:24,040 --> 00:41:27,330
如果只是从用户  我这里获取  好像有点不太准确

997
00:41:27,330 --> 00:41:31,300
我们得交出

998
00:41:31,300 --> 00:41:32,850
该函数从用户那里得到的一切信息

999
00:41:33,210 --> 00:41:36,820
调用GetString获取的信息也有可能

1000
00:41:36,820 --> 00:41:39,540
是通过键盘敲进来的

1001
00:41:39,540 --> 00:41:41,230
东西

1002
00:41:41,230 --> 00:41:44,120
它将会返回句子啊 单词啊

1003
00:41:44,120 --> 00:41:45,430
或词组啊等等一些信息

1004
00:41:45,800 --> 00:41:46,860
我们之所以

1005
00:41:46,860 --> 00:41:49,030
在第二行代码GetString前面加上等号

1006
00:41:49,030 --> 00:41:51,690
是因为这个函数会带回一个

1007
00:41:51,860 --> 00:41:52,770
返回值

1008
00:41:53,020 --> 00:41:55,220
它不仅要做好自己的本分工作

1009
00:41:55,430 --> 00:41:58,040
还要将获取到的值返还给我们

1010
00:41:58,270 --> 00:42:00,640
否则的话  它不把值带给我们

1011
00:42:00,640 --> 00:42:02,090
我们就做不了想做的事情

1012
00:42:02,090 --> 00:42:04,080
那我们还要它有什么用呢?

1013
00:42:04,240 --> 00:42:08,850
很庆幸我们为返回值预留了存储空间

1014
00:42:08,850 --> 00:42:10,240
我们可以临时分配一个变量

1015
00:42:10,520 --> 00:42:12,740
将这个值暂时存放在这个变量中

1016
00:42:12,740 --> 00:42:15,290
我不再把名字写死为D-A-V-I-D

1017
00:42:15,550 --> 00:42:16,820
而是用一个变量来代替

1018
00:42:17,090 --> 00:42:18,890
把变量放在这

1019
00:42:18,890 --> 00:42:22,040
我们先不要管这个string是什么  GetString会负责

1020
00:42:22,200 --> 00:42:23,870
从用户那里获取该值

1021
00:42:24,090 --> 00:42:26,280
我还是要用到printf

1022
00:42:26,710 --> 00:42:29,770
来把它转换成格式化字符串

1023
00:42:30,020 --> 00:42:32,500
运行看一下

1024
00:42:32,500 --> 00:42:38,270
GCC hi3 c   我有点厌烦这个a out的名字了

1025
00:42:38,270 --> 00:42:41,470
如果我想换个名字  大家应该知道怎么做吧

1026
00:42:41,470 --> 00:42:43,870
-o hi3 随便你们怎么叫

1027
00:42:43,870 --> 00:42:49,210
回车 oh不妙  有问题  先一起解决这个问题

1028
00:42:49,440 --> 00:42:52,190
记住我是怎么解决这个问题的  否则就是一次

1029
00:42:52,190 --> 00:42:52,990
无意义的演练了  对吧

1030
00:42:53,580 --> 00:42:54,680
那么  这儿到底有什么问题呢?

1031
00:42:54,680 --> 00:42:55,640
字体有点大

1032
00:42:55,640 --> 00:42:57,290
一般来说  问题都不会很复杂

1033
00:42:57,290 --> 00:42:58,700
但是还是看起来有点神秘  不是吗?

1034
00:42:58,700 --> 00:43:02,620
我在这运行了一条命令  GCC -o

1035
00:43:03,500 --> 00:43:07,140
这台投影仪我一天到晚的开着

1036
00:43:07,140 --> 00:43:08,340
一再强调屏幕上的东西  不幸地  你们却

1037
00:43:08,340 --> 00:43:09,990
在投影仪上没有看到它

1038
00:43:10,380 --> 00:43:14,220
好吧  我刚运行了一条GCC命令  然后我们得到了这一个

1039
00:43:14,220 --> 00:43:14,960
报错信息

1040
00:43:14,960 --> 00:43:17,700
错误信息从/tmp开始

1041
00:43:17,700 --> 00:43:19,370
其实这是无用信息

1042
00:43:19,560 --> 00:43:21,070
这只是

1043
00:43:21,070 --> 00:43:24,140
GCC为编译而临时

1044
00:43:24,140 --> 00:43:25,820
使用的存储空间--一个名曰temp的文件夹

1045
00:43:26,190 --> 00:43:27,740
并不是真正的结果

1046
00:43:27,980 --> 00:43:29,660
注意到这里的错误信息

1047
00:43:29,660 --> 00:43:34,950
上面说:有未定义的引用GetString  并收集到LD中

1048
00:43:34,950 --> 00:43:38,820
LD代表载入器  记住哦  你们稍后就会看到

1049
00:43:38,820 --> 00:43:39,920
这个细节的有用之出

1050
00:43:40,310 --> 00:43:42,490
载入器返回1退出当前状态

1051
00:43:42,630 --> 00:43:45,870
只凭直觉  这会是一个什么样的问题呢?

1052
00:43:46,050 --> 00:43:47,300
如果知道答案

1053
00:43:47,300 --> 00:43:49,060
知道问题的关键所在  先不要说出来

1054
00:43:49,170 --> 00:43:50,790
其实看字面  就应该猜到

1055
00:43:50,790 --> 00:43:51,650
这是什么意思了

1056
00:43:52,320 --> 00:43:53,730
>> 找不到GetString

1057
00:43:53,840 --> 00:43:55,260
>> 编译器找不到GetString  对吗?

1058
00:43:55,330 --> 00:43:56,130
谢谢这位同学  回答正确

1059
00:43:56,130 --> 00:43:58,630
CS50某位员工写了GetString这个函数

1060
00:43:58,990 --> 00:44:03,230
我们已经在头文件cs50 h中包含进去了

1061
00:44:03,750 --> 00:44:06,860
但这只是为我们调用源代码

1062
00:44:06,860 --> 00:44:08,650
提供了一条通道

1063
00:44:09,040 --> 00:44:10,930
这些构成该库的比特--0啊1啊

1064
00:44:10,970 --> 00:44:13,410
却是在cs50 c文件里

1065
00:44:13,410 --> 00:44:17,690
这些源代码

1066
00:44:17,690 --> 00:44:18,640
可以说是根本不存在

1067
00:44:18,720 --> 00:44:19,930
严格来讲  它们其实位于

1068
00:44:19,930 --> 00:44:22,850
名曰cs50 o的文件里  而现在

1069
00:44:22,850 --> 00:44:26,330
我们先不谈cs50 c

1070
00:44:26,330 --> 00:44:29,990
也不提cs50 o  当下要解决的问题

1071
00:44:30,020 --> 00:44:33,290
是GCC知道我要调用一个GetString函数

1072
00:44:33,610 --> 00:44:35,630
但是它不知道源代码位于哪里

1073
00:44:35,630 --> 00:44:38,750
怎样才能把别人写的代码

1074
00:44:38,750 --> 00:44:41,180
整合到你自己写的代码中

1075
00:44:41,370 --> 00:44:43,120
变成一个整体呢

1076
00:44:43,400 --> 00:44:45,850
好像有两步要走

1077
00:44:45,850 --> 00:44:48,200
当你想使用一些CS50的库

1078
00:44:48,420 --> 00:44:51,060
不是只运行GCC就够了

1079
00:44:51,290 --> 00:44:54,090
你还要在命名末尾告诉编译器

1080
00:44:54,090 --> 00:44:57,560
知道吗--加上转换器

1081
00:44:57,610 --> 00:45:00,930
l  是L不是1哦

1082
00:45:01,140 --> 00:45:04,640
即-l  然后是什么库?

1083
00:45:04,720 --> 00:45:05,810
对  CS50库

1084
00:45:06,240 --> 00:45:11,300
同样也可以是-lstd

1085
00:45:11,300 --> 00:45:12,910
即标准输入输出库

1086
00:45:13,120 --> 00:45:16,050
由于大家都会用到标准输入输出库

1087
00:45:16,050 --> 00:45:19,480
因此我们不要求每次都在后面添上-lstdio

1088
00:45:19,480 --> 00:45:21,060
可以省略

1089
00:45:21,220 --> 00:45:23,850
但是CS50库就没那么出名了

1090
00:45:24,010 --> 00:45:26,720
所以你必须在后面清清楚楚地添上-lcs50

1091
00:45:26,980 --> 00:45:27,990
为啥之间没有空格?

1092
00:45:28,360 --> 00:45:30,600
还是规定  必须先写-l

1093
00:45:30,600 --> 00:45:31,660
再跟上库的名称

1094
00:45:31,910 --> 00:45:32,860
好  回车

1095
00:45:33,610 --> 00:45:37,480
好啦  错误信息消失了

1096
00:45:37,480 --> 00:45:38,060
这说明你编译成功了

1097
00:45:38,550 --> 00:45:40,140
hi3 回车

1098
00:45:41,090 --> 00:45:44,730
oh-oh  没有该命令

1099
00:45:44,900 --> 00:45:46,170
现在又是什么问题呢?

1100
00:45:46,440 --> 00:45:48,010
我不是把它命名成hi3?

1101
00:45:48,010 --> 00:45:51,640
我的确敲进去-o hi3啊

1102
00:45:51,640 --> 00:45:54,870
为什么没有找到该命令呢?

1103
00:45:54,950 --> 00:45:56,280
嗯哼?

1104
00:45:56,330 --> 00:45:57,370
>>它不知道hi3在哪

1105
00:45:57,430 --> 00:45:59,010
>>对  它不知道hi3在哪

1106
00:45:59,050 --> 00:46:01,740
我再说一遍  事实上   电脑-

1107
00:46:01,960 --> 00:46:04,830
你知道的  在某些人看来  很尖端 很高科技

1108
00:46:05,030 --> 00:46:06,190
其实它很笨的

1109
00:46:06,190 --> 00:46:07,120
除非你告诉它要做什么

1110
00:46:07,120 --> 00:46:08,550
它自己是不知道做什么的

1111
00:46:08,760 --> 00:46:12,940
默认情况下  PC机

1112
00:46:13,160 --> 00:46:16,170
只会运行C:\programs file下的程序

1113
00:46:16,400 --> 00:46:18,790
或者是Mac机的/application目录下

1114
00:46:19,060 --> 00:46:22,550
至于我刚刚创建的hi3

1115
00:46:22,550 --> 00:46:24,450
它正好位于我电脑不知道的位置

1116
00:46:24,450 --> 00:46:27,650
所以你必须敲入 /   这代表当前目录

1117
00:46:27,650 --> 00:46:32,350
代表我当前目录  /表明hi3位于此处

1118
00:46:32,580 --> 00:46:34,010
现在程序就能运行了

1119
00:46:34,010 --> 00:46:36,550
看  State your name

1120
00:46:36,660 --> 00:46:40,360
再现了之前做过的事情

1121
00:46:40,580 --> 00:46:41,600
其中有动态部分

1122
00:46:41,740 --> 00:46:42,980
也有静态的

1123
00:46:42,980 --> 00:46:43,860
我们再来一次

1124
00:46:44,080 --> 00:46:44,890
输入你的名字

1125
00:46:44,890 --> 00:46:46,680
名字就叫Cansu吧  回车

1126
00:46:47,340 --> 00:46:50,580
有一个S喔  C-A-N-S-U

1127
00:46:50,580 --> 00:46:53,250
她的名字叫Cansu  她会很感谢你

1128
00:46:53,250 --> 00:46:55,410
因为你跟她打招呼的时候  记住了她的名字

1129
00:46:55,410 --> 00:46:56,610
顺便说一下  Cansu是我们的TF头

1130
00:46:56,680 --> 00:46:57,770
所以Cansu  oh hi Cansu!

1131
00:46:57,770 --> 00:46:58,730
我们可以一天到晚都做这个事

1132
00:46:59,100 --> 00:47:01,730
为您提供各种形式的输入

1133
00:47:01,810 --> 00:47:03,200
程序也一直工作

1134
00:47:03,200 --> 00:47:05,470
我们也可以控制它

1135
00:47:05,510 --> 00:47:08,690
这么听起来  好像将要

1136
00:47:08,690 --> 00:47:10,330
讨论安全方面的问题了

1137
00:47:10,600 --> 00:47:12,190
其实你也可以恶搞一下电脑

1138
00:47:12,190 --> 00:47:13,110
好也罢坏也罢  都行

1139
00:47:13,110 --> 00:47:14,510
比如  在这里什么都不敲

1140
00:47:15,160 --> 00:47:15,970
蛮怪的哈

1141
00:47:16,240 --> 00:47:20,270
这次我什么都没做  然后就显示 oh  hi null

1142
00:47:20,270 --> 00:47:21,690
有点意思

1143
00:47:21,690 --> 00:47:23,210
这对于即将讨论的安全性问题来说

1144
00:47:23,210 --> 00:47:26,260
只是一个小插曲  随着科技的发展

1145
00:47:26,260 --> 00:47:28,910
很多时候  如果(下载)工具受损

1146
00:47:28,910 --> 00:47:30,460
你会下载到一个版本不全的Photoshop

1147
00:47:30,460 --> 00:47:31,310
或其他类似的东西

1148
00:47:31,560 --> 00:47:33,590
很多时候  当要访问的网站被人破坏了

1149
00:47:33,590 --> 00:47:35,130
你就有机会窃取别人的账号

1150
00:47:35,130 --> 00:47:37,470
和密码  正是因为这样或那样的小疏忽存在

1151
00:47:37,470 --> 00:47:39,820
才会导致这种事情频频发生

1152
00:47:39,820 --> 00:47:43,270
就拿这个程序说事吧  我们根本没有检查

1153
00:47:43,270 --> 00:47:45,980
用户到底有没有输入

1154
00:47:45,980 --> 00:47:48,440
没有检查变量的长度

1155
00:47:48,670 --> 00:47:49,350
也没有检查

1156
00:47:49,350 --> 00:47:51,410
GetString到底有没有返回用户值

1157
00:47:51,410 --> 00:47:53,990
如果  我们没有敲入名字

1158
00:47:53,990 --> 00:47:57,400
比如D-A-V-I-D就回车  而是敲入一些命令

1159
00:47:57,450 --> 00:47:59,540
譬如"我不会把名字告诉你的"

1160
00:48:00,060 --> 00:48:03,020
各种古怪的事情就会蜂拥而至

1161
00:48:03,020 --> 00:48:05,920
所以在这个课程中我反复强调

1162
00:48:05,920 --> 00:48:08,920
要一丝不苟地检查错误

1163
00:48:09,080 --> 00:48:12,660
你就当你的用户是个调皮捣蛋的家伙

1164
00:48:12,850 --> 00:48:14,570
或者说是你的敌人

1165
00:48:14,570 --> 00:48:17,210
而且千方百计地要破坏你的程序

1166
00:48:17,210 --> 00:48:20,880
唉  这种漏洞百出的软件我见过的是在太多了

1167
00:48:21,110 --> 00:48:27,170
说到这  还有谁有问题?

1168
00:48:27,250 --> 00:48:27,740
>>有

1169
00:48:27,830 --> 00:48:28,500
>>恩

1170
00:48:28,570 --> 00:48:29,850
>>恩  我想说

1171
00:48:29,920 --> 00:48:31,040
我有一个字符串……(声音很小)

1172
00:48:31,040 --> 00:48:34,550
但是这意味着什么?

1173
00:48:34,550 --> 00:48:36,090
是字符串?单词?还是?

1174
00:48:36,090 --> 00:48:37,590
>>你刚刚说什么? 一个字符串?

1175
00:48:37,650 --> 00:48:39,460
>> 它后面应该跟什么呢?

1176
00:48:39,460 --> 00:48:40,440
>> 问得好!

1177
00:48:40,440 --> 00:48:43,420
那么  我们还是回到这里  略去一些

1178
00:48:43,420 --> 00:48:44,690
没用的细节

1179
00:48:45,110 --> 00:48:47,330
今天我们就讨论这个话题

1180
00:48:47,330 --> 00:48:50,840
大家上个星期应该从

1181
00:48:50,840 --> 00:48:53,490
软盘得知电脑上其实有

1182
00:48:53,490 --> 00:48:54,720
很多种存储装备

1183
00:48:54,720 --> 00:48:55,840
我们知道的有  譬如硬盘

1184
00:48:55,840 --> 00:48:57,190
RAM(随机存取存储器)

1185
00:48:57,190 --> 00:48:58,740
RAM就是一个存储器

1186
00:48:58,740 --> 00:49:00,380
当你运行一个程序时  可以把数据临时

1187
00:49:00,380 --> 00:49:01,370
存放在里面

1188
00:49:01,710 --> 00:49:03,470
你们应该都有一个十亿字节

1189
00:49:03,470 --> 00:49:05,130
或二十亿字节的RAM

1190
00:49:05,400 --> 00:49:07,070
请大家注意这个关键词"字节"

1191
00:49:07,070 --> 00:49:09,690
我们所说的十亿字节就是有十亿个字节

1192
00:49:10,100 --> 00:49:12,800
也就是说  无论你的电脑是Mac也好  PC也好或其他什么的

1193
00:49:13,020 --> 00:49:15,890
你会有厚厚一块RAM存储器

1194
00:49:15,890 --> 00:49:18,140
我们可以把它画成长方形  你们有可能看不到

1195
00:49:18,140 --> 00:49:18,950
它就是长方形的

1196
00:49:19,310 --> 00:49:23,360
由于有十亿个字节的存储量供我们使用

1197
00:49:23,510 --> 00:49:27,210
也就是说  我们有0号字节

1198
00:49:27,410 --> 00:49:28,890
1号字节

1199
00:49:28,890 --> 00:49:30,430
2号 3号等等

1200
00:49:30,430 --> 00:49:31,930
这是一整块的

1201
00:49:31,930 --> 00:49:34,640
我只是把它划分成一个个小区域

1202
00:49:34,640 --> 00:49:36,130
每个小区域都可以设定一个地址

1203
00:49:36,170 --> 00:49:37,810
你可以给每个字节编号

1204
00:49:37,810 --> 00:49:39,370
就像你给街上每栋房子编号一样

1205
00:49:39,800 --> 00:49:42,960
我们再回到程序里  向用户要一个字符串

1206
00:49:43,230 --> 00:49:45,900
一个字符串是由一系列字母构成

1207
00:49:46,020 --> 00:49:49,130
在这里  就是一系列ASCII码

1208
00:49:49,130 --> 00:49:51,440
回想一下我们上周提到的ASCII码

1209
00:49:51,670 --> 00:49:54,550
大写字母A就是65

1210
00:49:54,550 --> 00:49:56,700
我现在跟大家讲一下  电脑如何存储字母

1211
00:49:56,930 --> 00:49:59,250
譬如你有这么一个字符串D-A-V-I-D

1212
00:49:59,460 --> 00:50:02,480
而在你电脑的RAM里将会变成

1213
00:50:02,480 --> 00:50:04,930
一个个由0和1组成的字节

1214
00:50:05,040 --> 00:50:06,630
>> 你们自己算算看

1215
00:50:06,630 --> 00:50:09,910
把这些0和1转换成D对应的ASCII码

1216
00:50:09,910 --> 00:50:14,660
那么就是  65 66 67 68  对  68对应于"D"

1217
00:50:14,930 --> 00:50:17,500
同样  A就是65

1218
00:50:17,500 --> 00:50:20,940
接着再填上V-I-D对应的ASCII码

1219
00:50:20,940 --> 00:50:23,340
在最后还有添上一个特殊的字符

1220
00:50:23,610 --> 00:50:25,920
有点像0  代表这是该字符串结束

1221
00:50:26,250 --> 00:50:28,950
所以当你调用cs50员工写的这个

1222
00:50:28,950 --> 00:50:30,330
GetString函数时

1223
00:50:30,560 --> 00:50:33,650
我们要做的就是弄清楚怎样把

1224
00:50:33,650 --> 00:50:35,130
用户的输入

1225
00:50:35,270 --> 00:50:37,170
存储在像那样的单独的存储单元里面

1226
00:50:37,580 --> 00:50:39,040
当我们返回该字符串时

1227
00:50:39,040 --> 00:50:41,640
我们实际上是告诉你

1228
00:50:41,640 --> 00:50:43,780
这块存储单元位于哪里

1229
00:50:44,040 --> 00:50:45,940
这样我们就可以打印出来  或改变其值

1230
00:50:45,940 --> 00:50:49,740
对它进行操作  等等

1231
00:50:49,740 --> 00:50:50,380
【听不清】

1232
00:50:50,380 --> 00:50:52,480
>> 这一行字节就是所谓的

1233
00:50:52,480 --> 00:50:52,760
>> 字符串

1234
00:50:52,760 --> 00:50:53,140
>> 没错

1235
00:50:53,140 --> 00:50:55,060
字符串就是一串

1236
00:50:55,060 --> 00:50:56,800
字符  亦称字节

1237
00:50:57,930 --> 00:50:58,490
还有其他问题吗?

1238
00:50:59,230 --> 00:50:59,390
嗯哼?

1239
00:51:00,830 --> 00:51:03,400
>>在这个系统上编译

1240
00:51:03,400 --> 00:51:04,930
跟在我们这编译有什么不同吗?

1241
00:51:04,930 --> 00:51:08,090
也就是说  有没有其他的编译器供C++等语言使用?

1242
00:51:08,290 --> 00:51:08,790
>>问得好

1243
00:51:08,790 --> 00:51:11,110
GCC里面的程序跟

1244
00:51:11,110 --> 00:51:14,550
其他编译器譬如DEV++ Visual Studio

1245
00:51:15,360 --> 00:51:17,650
Eclipse  NetBeans等等之间的区别

1246
00:51:17,900 --> 00:51:19,500
实际上  很小

1247
00:51:19,590 --> 00:51:21,190
对于你们这些

1248
00:51:21,190 --> 00:51:23,750
有着高中电脑知识背景的同学可能一般用

1249
00:51:24,850 --> 00:51:26,550
即"集成开发环境"

1250
00:51:26,710 --> 00:51:29,440
它有一些菜单 图标等等

1251
00:51:29,440 --> 00:51:30,780
你们可以在上面写源代码

1252
00:51:30,990 --> 00:51:33,300
如果要编译的话  不用像GCC这样要输入命令 文件名

1253
00:51:33,330 --> 00:51:35,840
只需点击按钮就可以了

1254
00:51:36,100 --> 00:51:37,880
我们等一下再回到这一点

1255
00:51:38,180 --> 00:51:40,500
作为一种

1256
00:51:40,500 --> 00:51:41,940
理解电脑工作机制

1257
00:51:41,940 --> 00:51:43,490
和在低平台上编程的入门方法

1258
00:51:43,650 --> 00:51:45,930
我们可以在低平台上运行GCC

1259
00:51:46,240 --> 00:51:47,960
实际上只是特点与众不同而已

1260
00:51:47,960 --> 00:51:51,510
GCC可能是全世界最有名的编译器了

1261
00:51:51,760 --> 00:51:54,170
因为它历史悠久

1262
00:51:54,170 --> 00:51:55,980
而且很多软件都依附在GCC上

1263
00:51:56,070 --> 00:51:58,670
由于其自身的特点而很受限制

1264
00:51:58,880 --> 00:52:00,850
但是可以对这些特征进行备份

1265
00:52:01,330 --> 00:52:02,030
还有什么问题?

1266
00:52:02,580 --> 00:52:02,690
恩 你说

1267
00:52:02,690 --> 00:52:04,940
>> 在Makefile之前吗?

1268
00:52:04,940 --> 00:52:05,210
>>对

1269
00:52:05,370 --> 00:52:09,840
>> 编译器和Makefile有什么区别?

1270
00:52:09,840 --> 00:52:11,780
>>好问题  我们还没有一个Makefile文件

1271
00:52:11,780 --> 00:52:12,730
更多精彩  尽在以后的课程

1272
00:52:12,730 --> 00:52:14,010
但是我们会用到make命令

1273
00:52:14,450 --> 00:52:17,070
从本质上来看  make命令就是一个

1274
00:52:17,290 --> 00:52:20,350
调用GCC来编译我们程序的程序

1275
00:52:20,720 --> 00:52:22,480
只不过make是可以配置的

1276
00:52:22,660 --> 00:52:25,190
刚刚我们提到自己动手敲

1277
00:52:25,190 --> 00:52:28,160
一些像/lcs50还有/0 hello这样的命令

1278
00:52:28,320 --> 00:52:29,780
是不是敲得你们脖子都酸了?

1279
00:52:29,780 --> 00:52:30,760
如果你写一个程序

1280
00:52:30,760 --> 00:52:32,370
检测 然后重新编译

1281
00:52:32,580 --> 00:52:33,900
你们很快就会乏味

1282
00:52:33,940 --> 00:52:35,520
一遍又一遍地输入同样的命令

1283
00:52:35,520 --> 00:52:38,420
但是make却是可以配置的  你们很快就会看到

1284
00:52:38,420 --> 00:52:41,290
在习题集2 3中  我会演示给你们看

1285
00:52:41,290 --> 00:52:43,710
它可以让我们从这些重复乏味的工作中

1286
00:52:44,010 --> 00:52:47,080
解脱出来

1287
00:52:47,890 --> 00:52:48,870
还有什么问题?

1288
00:52:50,220 --> 00:52:52,600
好吧  那我们--嗯?

1289
00:52:53,060 --> 00:52:57,100
>>那个 /a out

1290
00:52:57,400 --> 00:52:57,510
>> 嗯

1291
00:52:57,750 --> 00:53:02,500
>>它只有在你运行程序的时候才用到

1292
00:53:03,970 --> 00:53:05,570
那你刚刚提到的程序

1293
00:53:05,570 --> 00:53:06,480
会到你的电脑上运行吗?

1294
00:53:06,480 --> 00:53:06,980
>>对

1295
00:53:07,070 --> 00:53:09,670
当程序位于你的电脑上时  敲入 /

1296
00:53:10,700 --> 00:53:12,810
就意味着在我的电脑上运行

1297
00:53:12,810 --> 00:53:13,640
>> 那个是(听不见的声音)你用到的

1298
00:53:13,640 --> 00:53:14,780
其他程序  GCC oh hi--

1299
00:53:14,780 --> 00:53:15,810
>>完全正确

1300
00:53:15,810 --> 00:53:17,530
注意  GCC使用一种特殊的安装程序安装

1301
00:53:17,530 --> 00:53:19,100
位于硬件的某个地方

1302
00:53:19,100 --> 00:53:20,910
它并不在我当前文件夹  但是由于我安装了

1303
00:53:20,910 --> 00:53:22,800
某个程序  双击的那种  然后一切都搞定

1304
00:53:23,030 --> 00:53:23,790
在我的Mac机

1305
00:53:23,790 --> 00:53:25,810
或者是我们现在的这个Linux服务器上把它设置成

1306
00:53:25,810 --> 00:53:28,270
自动放到我知道的

1307
00:53:28,270 --> 00:53:29,440
路径下

1308
00:53:30,560 --> 00:53:32,750
返回的时候也需要返回这么多层

1309
00:53:32,980 --> 00:53:37,450
总结起来  就是几个命令 一个有意思的代码

1310
00:53:37,880 --> 00:53:40,160
然后是那个小技巧  那是一个小技巧

1311
00:53:40,160 --> 00:53:41,480
在这输入命令LS

1312
00:53:41,860 --> 00:53:44,880
从字面上来看  好像

1313
00:53:44,880 --> 00:53:47,070
看不出来它是干嘛的  但是当我第一次登录到

1314
00:53:47,070 --> 00:53:49,410
"云"  好像是这样的提示

1315
00:53:49,760 --> 00:53:52,230
LS是列表命令  你们中用过DOS的

1316
00:53:52,230 --> 00:53:54,310
恐怕会想起DIR

1317
00:53:54,590 --> 00:53:57,080
当你输入LS时  它会把你当前目录下的文件罗列出来

1318
00:53:57,330 --> 00:54:00,740
当前目录或者根目录

1319
00:54:00,820 --> 00:54:04,100
在"云"上属于我的文件夹  或者

1320
00:54:04,100 --> 00:54:08,120
我自己的Mac机  或PC机上  很明显有两个

1321
00:54:08,120 --> 00:54:08,860
子文件夹

1322
00:54:09,070 --> 00:54:12,870
其中一个叫SRC  用来装源代码  另一个叫SRC back

1323
00:54:13,160 --> 00:54:15,720
用来备份源代码  以防我搞砸了

1324
00:54:16,070 --> 00:54:19,040
如果进入一个目录  你们会发现

1325
00:54:19,040 --> 00:54:20,230
所有步骤都在

1326
00:54:20,230 --> 00:54:21,380
第一个习题集中提到过

1327
00:54:21,380 --> 00:54:24,280
如果你们没有完全吸收我今天讲的内容  没关系

1328
00:54:24,280 --> 00:54:25,760
这些小细节都会在习题集中找得到

1329
00:54:26,210 --> 00:54:27,820
CD就是改变目录的意思

1330
00:54:28,030 --> 00:54:30,660
输入cd src  回车

1331
00:54:30,830 --> 00:54:33,070
注意到没?前面的提示改变了一点点

1332
00:54:33,070 --> 00:54:35,920
在圆括号里的~

1333
00:54:35,920 --> 00:54:37,340
代表根目录

1334
00:54:37,720 --> 00:54:40,510
src代表当前进入的目录

1335
00:54:40,730 --> 00:54:42,950
如果再敲入LS  回车

1336
00:54:43,160 --> 00:54:44,560
我们会看到一大推文件

1337
00:54:44,560 --> 00:54:48,180
全部都是一些为这周准备的打印资料

1338
00:54:48,180 --> 00:54:50,110
都是一些C文件

1339
00:54:50,110 --> 00:54:52,120
就是这个文件夹包含了所有

1340
00:54:52,360 --> 00:54:54,930
最终我们用PDF列出来的东西

1341
00:54:55,140 --> 00:54:58,640
其中绿色的文件是可以运行的

1342
00:54:58,640 --> 00:55:01,450
只要合理设置一下命令行环境

1343
00:55:01,450 --> 00:55:04,270
就可以看到  这些所谓的

1344
00:55:04,340 --> 00:55:05,310
执行文件

1345
00:55:05,310 --> 00:55:07,450
譬如a out啊等  都会变成绿色

1346
00:55:07,500 --> 00:55:08,750
hi3 就是绿色的

1347
00:55:08,920 --> 00:55:11,470
而其他部分白色文件都是些源代码

1348
00:55:11,470 --> 00:55:12,740
都是 c文件

1349
00:55:12,960 --> 00:55:16,470
我又要给大家出难题了

1350
00:55:16,820 --> 00:55:20,030
这里有一个文件Holloway c  不是程序

1351
00:55:20,030 --> 00:55:21,560
我们马上就要清除掉它

1352
00:55:21,560 --> 00:55:23,600
我希望你们现在就开始写程序

1353
00:55:23,920 --> 00:55:25,830
否则你们将会在C语言比赛中

1354
00:55:25,830 --> 00:55:28,020
写得非常糟糕

1355
00:55:28,170 --> 00:55:31,090
这个世界上还是有很多怪人

1356
00:55:31,090 --> 00:55:33,730
和别人比赛看谁写出来的程序

1357
00:55:33,730 --> 00:55:35,910
更复杂

1358
00:55:36,230 --> 00:55:38,120
这恐怕需要电脑才能

1359
00:55:38,120 --> 00:55:39,520
分析它们的工作原理

1360
00:55:40,040 --> 00:55:41,050
这就是其中一个程序

1361
00:55:41,050 --> 00:55:43,090
排版不是很整齐

1362
00:55:43,090 --> 00:55:44,960
看起来也非常复杂  不是吗?

1363
00:55:44,960 --> 00:55:46,770
我不得不承认  恐怕我读完后

1364
00:55:46,770 --> 00:55:48,720
也不能告诉你它都干了些什么

1365
00:55:48,720 --> 00:55:50,660
除非我完完全全被这些细节给迷住了

1366
00:55:50,660 --> 00:55:52,560
这儿还有一些我们从未见过的语法

1367
00:55:52,560 --> 00:55:54,900
这个define关键词  我们稍后会讲到

1368
00:55:54,900 --> 00:55:56,900
long也是

1369
00:55:57,080 --> 00:55:58,770
还有这些方括号

1370
00:55:59,060 --> 00:56:01,180
看起来是相当复杂啊

1371
00:56:01,660 --> 00:56:06,190
对于这些更舒适点的东西  它干了些啥事呢?

1372
00:56:06,420 --> 00:56:06,780
你知道吗?

1373
00:56:07,480 --> 00:56:11,050
那一年的冠军

1374
00:56:11,050 --> 00:56:12,320
就是2003年左右

1375
00:56:12,320 --> 00:56:13,470
我包含了那个长度  我们继续

1376
00:56:13,470 --> 00:56:16,460
编译这个Holloway c程序

1377
00:56:16,460 --> 00:56:17,260
零错误  非常好

1378
00:56:17,260 --> 00:56:21,520
运行a out  这类麻烦的程序

1379
00:56:21,520 --> 00:56:24,190
你多年多年之后也能写

1380
00:56:24,190 --> 00:56:27,010
因为最后的结果是这样的

1381
00:56:27,880 --> 00:56:31,350
休息一下

1382
00:56:31,420 --> 00:56:34,360
>> 我们先休息五分钟

1383
00:56:35,820 --> 00:56:39,090
好吧  我们又回来了

1384
00:56:39,090 --> 00:56:41,900
前人多栽树

1385
00:56:41,900 --> 00:56:44,340
后人易乘凉

1386
00:56:44,640 --> 00:56:47,280
printf就是这么一个泽被后人的函数

1387
00:56:47,320 --> 00:56:50,710
你们调用时要带上参数

1388
00:56:50,710 --> 00:56:53,540
可能是一个或多个参数

1389
00:56:53,570 --> 00:56:56,650
因为不同的参数会影响它的输出

1390
00:56:57,210 --> 00:56:59,240
比如之前看到的格式化字符串

1391
00:56:59,240 --> 00:57:01,520
我们知道字符串占位符%S

1392
00:57:01,810 --> 00:57:02,750
输出来就是另一番场景了

1393
00:57:02,750 --> 00:57:04,330
还有一些其他类型的占位符

1394
00:57:04,330 --> 00:57:06,530
如果你不想输出一个完整的字符串

1395
00:57:06,800 --> 00:57:10,060
而是输出一个字母  就要用到%C

1396
00:57:10,290 --> 00:57:14,280
%d代表以数字的形式输出  比如一个数字或者--1或更大的数

1397
00:57:14,280 --> 00:57:17,080
如果你想输出一个整数  我们将学习到的其他类型

1398
00:57:17,480 --> 00:57:20,030
F代表浮点型数据  那是表示

1399
00:57:20,030 --> 00:57:21,110
实数的一个设计方式

1400
00:57:21,110 --> 00:57:23,420
也就是小数点后还有数字

1401
00:57:23,700 --> 00:57:25,520
然后是lld  我们等会就会看到

1402
00:57:25,520 --> 00:57:28,010
这个代表长整型数据

1403
00:57:28,010 --> 00:57:30,600
它是相当重要的  特别是当你需要

1404
00:57:30,600 --> 00:57:32,050
处理大量信息的时候

1405
00:57:32,360 --> 00:57:34,730
还有反斜杠n  不仅C语言里有

1406
00:57:34,730 --> 00:57:37,800
在其他语言像PHP JavaScript等都会碰到

1407
00:57:38,440 --> 00:57:40,560
如果你想与其他字符隔开

1408
00:57:40,790 --> 00:57:43,010
你就要用到所谓的转义字符

1409
00:57:43,080 --> 00:57:45,660
这是一种简写方式

1410
00:57:45,740 --> 00:57:47,590
通常需要两到三个字符

1411
00:57:47,930 --> 00:57:50,720
这些字符你们在屏幕上是

1412
00:57:50,720 --> 00:57:53,190
看不到的  这个是换行字符

1413
00:57:53,370 --> 00:57:55,300
你也可以敲回车键

1414
00:57:55,430 --> 00:57:57,770
但是会让你的代码看起来乱七八糟

1415
00:57:57,770 --> 00:57:59,490
反斜杠n就是换行符

1416
00:57:59,810 --> 00:58:04,070
这还有\r  谁知道\r代表什么?

1417
00:58:04,520 --> 00:58:06,280
对  是回车的意思

1418
00:58:06,620 --> 00:58:09,400
如果你们有谁曾经看过或用过老式打字机

1419
00:58:09,650 --> 00:58:11,640
可能还记得  当你在

1420
00:58:11,640 --> 00:58:13,650
这种老式打字机上打字的时候

1421
00:58:13,940 --> 00:58:15,550
当你

1422
00:58:15,550 --> 00:58:18,770
敲入回车键  跳转到

1423
00:58:18,810 --> 00:58:21,340
下一行的最左边  或者

1424
00:58:21,340 --> 00:58:24,020
拉一下杆  这个需要两步走

1425
00:58:24,020 --> 00:58:27,140
拉杆或按下按钮会让纸翻一下

1426
00:58:27,140 --> 00:58:29,490
这样你就能在新的一行上打字了

1427
00:58:29,590 --> 00:58:31,620
同时移动打印字母的

1428
00:58:31,620 --> 00:58:33,020
压印头

1429
00:58:33,020 --> 00:58:34,480
这样也能移到最左边

1430
00:58:34,480 --> 00:58:38,320
你们可以把换行想象成翻纸

1431
00:58:38,320 --> 00:58:42,010
把回车当做是将光标

1432
00:58:42,010 --> 00:58:44,670
移动到最左边

1433
00:58:45,310 --> 00:58:49,490
在Linux和Unix里更广泛

1434
00:58:49,490 --> 00:58:52,480
对了  这两个都是历史悠久的

1435
00:58:52,480 --> 00:58:54,760
操作系统  就连Mac操作系统

1436
00:58:54,760 --> 00:58:56,630
都是基于它的一个版本设计出来的

1437
00:58:56,630 --> 00:58:58,510
我是指  这学期  你们会很高兴

1438
00:58:59,020 --> 00:59:03,180
和它打交道  同时你们也会看到

1439
00:59:03,180 --> 00:59:06,110
在任何文本文件里  反斜杠n已经是

1440
00:59:06,490 --> 00:59:10,190
换行的代名词了

1441
00:59:10,190 --> 00:59:12,000
换句话说  如果你们用的Linux操作系统

1442
00:59:12,250 --> 00:59:14,690
也会用到nano vim

1443
00:59:14,910 --> 00:59:17,640
Text Edit或Notepad  这些功能都差不多

1444
00:59:17,640 --> 00:59:19,570
当你保存文件

1445
00:59:19,570 --> 00:59:22,790
敲回车键时  会保存在存储器里

1446
00:59:22,790 --> 00:59:25,830
以这样字节的形式保存在磁盘 RAM里

1447
00:59:26,070 --> 00:59:30,750
对应的字节就是反斜杠n  很不幸

1448
00:59:30,780 --> 00:59:33,330
在Windows下(要麻烦一些)

1449
00:59:33,330 --> 00:59:36,480
有点像打字机

1450
00:59:36,480 --> 00:59:39,950
不仅要保存反斜杠n反斜杠--

1451
00:59:40,120 --> 00:59:45,760
不对  是反斜个r反斜杠n  在每行末

1452
00:59:45,930 --> 00:59:47,200
都需要两个字节

1453
00:59:47,200 --> 00:59:50,700
在Notepad或Microsoft里  每当你敲回车键时

1454
00:59:50,700 --> 00:59:53,040
没有恶意哈  这两个字符

1455
00:59:53,040 --> 00:59:54,100
都会保存在文档里

1456
00:59:54,410 --> 00:59:56,000
有谁知道原因

1457
00:59:56,180 --> 01:00:00,140
Apple 保存的不是反斜杠n

1458
01:00:00,140 --> 01:00:03,470
而是反斜杠r

1459
01:00:03,470 --> 01:00:06,780
是不是很头大

1460
01:00:07,220 --> 01:00:09,240
即使是课下  在实验室

1461
01:00:09,240 --> 01:00:11,240
在某些工程中  当你使用文件

1462
01:00:11,240 --> 01:00:12,750
或仅仅只是打开文件

1463
01:00:12,970 --> 01:00:14,710
都会涉及到这些问题

1464
01:00:14,920 --> 01:00:17,560
这只是人们就"标准"讨论未果所造成的局面

1465
01:00:17,560 --> 01:00:18,970
只是处事方式不同而已

1466
01:00:19,100 --> 01:00:22,280
>>坦白说  这种现象在物质世界里处处可见

1467
01:00:22,480 --> 01:00:25,250
如果你注意到  你会发现  Mac操作系统

1468
01:00:25,250 --> 01:00:27,420
在其左上角是Apple菜单  Windows却把它的开始菜单

1469
01:00:27,420 --> 01:00:30,400
放在左下角  毫无理由可言

1470
01:00:30,400 --> 01:00:32,220
还有一个就是  在Windows操作系统下

1471
01:00:32,220 --> 01:00:34,340
当你要关闭某个东西时  需要点击

1472
01:00:34,340 --> 01:00:35,280
右上角的"X"

1473
01:00:35,520 --> 01:00:37,450
那在Mac操作系统下呢?

1474
01:00:37,450 --> 01:00:39,340
在左上角  是不是很没意义啊?

1475
01:00:39,340 --> 01:00:41,180
只是为了与众不同罢了

1476
01:00:41,180 --> 01:00:42,650
谁先谁后又有什么关系呢

1477
01:00:43,040 --> 01:00:44,360
都是一码事

1478
01:00:44,360 --> 01:00:46,600
我之所以提到这个是因为久而久之

1479
01:00:46,880 --> 01:00:49,170
当你自己写代码而不是读代码时

1480
01:00:49,170 --> 01:00:51,790
这会变得非常重要

1481
01:00:51,790 --> 01:00:54,260
当你检查拼写时

1482
01:00:54,260 --> 01:00:55,300
字典查询

1483
01:00:55,460 --> 01:00:57,050
当你熟练运用这些文本文件时

1484
01:00:57,050 --> 01:00:59,620
可能是写一些输出文本  这些小细节

1485
01:00:59,620 --> 01:01:02,950
恐怕可以帮助你合理解决问题

1486
01:01:02,950 --> 01:01:08,000
还有一些其他的转义字符  譬如\t 顾问界 财政界的

1487
01:01:08,000 --> 01:01:10,760
人们很喜欢用Excel文档

1488
01:01:10,760 --> 01:01:12,670
或类似于Excel的文本文件

1489
01:01:12,960 --> 01:01:16,010
CSV文件  如果你曾经打开过 csv文件

1490
01:01:16,300 --> 01:01:19,560
即"逗号分隔"文件  它实际上是一张表

1491
01:01:19,560 --> 01:01:21,880
但是用逗号分隔每一列

1492
01:01:22,050 --> 01:01:23,860
打开的时候又像Excel

1493
01:01:24,090 --> 01:01:27,930
而TSV文件  "制表符分隔"文件

1494
01:01:27,930 --> 01:01:28,930
顾名思义 就是用制表符来分隔每一列

1495
01:01:29,130 --> 01:01:31,430
如果你想输出一个真正的制表符

1496
01:01:31,430 --> 01:01:32,870
点击tab键

1497
01:01:33,120 --> 01:01:34,440
你也可以用\t

1498
01:01:34,440 --> 01:01:35,740
这就是那些文件的形成方式

1499
01:01:36,090 --> 01:01:38,180
有时我们需要你

1500
01:01:38,180 --> 01:01:40,440
用一些有实际意义的字符与其他字符隔开

1501
01:01:40,440 --> 01:01:43,110
比如用单引号隔开

1502
01:01:43,430 --> 01:01:45,670
有时候是双引号

1503
01:01:45,970 --> 01:01:49,290
凭直觉来看  迄今为止  你们什么时候

1504
01:01:49,600 --> 01:01:53,000
会用到\"呢?

1505
01:01:53,000 --> 01:01:53,500
举个例子

1506
01:01:53,500 --> 01:01:54,080
【听不清】

1507
01:01:54,080 --> 01:01:56,370
>>什么?

1508
01:01:56,940 --> 01:01:58,050
大声一点

1509
01:01:58,050 --> 01:01:58,730
【听不清】

1510
01:01:58,730 --> 01:02:01,460
>>如果是在字符串中间呢

1511
01:02:01,460 --> 01:02:02,940
像我们前面提到的printf("")

1512
01:02:02,940 --> 01:02:05,390
我们把要显示的东西放在双引号之间  譬如David

1513
01:02:05,390 --> 01:02:07,830
或 David反斜杠n  但是如果我自己的名字本来就叫

1514
01:02:07,830 --> 01:02:10,630
"David"(带双引号的David)

1515
01:02:10,630 --> 01:02:12,970
我要把我带双引号的名字放到

1516
01:02:12,970 --> 01:02:14,700
printf("")之间的时候  该怎么办?

1517
01:02:14,990 --> 01:02:17,640
也就是说  我希望双引号也显示出来

1518
01:02:17,870 --> 01:02:21,220
那么我们不仅要用到printf里面的双引号""

1519
01:02:21,480 --> 01:02:22,920
还要用到转义字符\"

1520
01:02:22,920 --> 01:02:26,230
你们也知道的  电脑很笨的

1521
01:02:26,320 --> 01:02:30,210
如果我双引号里面再套双引号

1522
01:02:30,210 --> 01:02:33,220
那电脑会怎么想呢?

1523
01:02:33,850 --> 01:02:35,950
可以看成是两个字符串  对吧?

1524
01:02:35,950 --> 01:02:37,180
一个从这里开始  在这里结束

1525
01:02:37,180 --> 01:02:38,440
然后是另一个

1526
01:02:38,570 --> 01:02:39,460
但这是不合法的

1527
01:02:39,460 --> 01:02:41,790
你不能让一个引起来的字符串跟另一个引起来的字符串

1528
01:02:41,890 --> 01:02:42,890
背靠背

1529
01:02:43,140 --> 01:02:44,750
这样编译就会出错

1530
01:02:44,750 --> 01:02:46,460
GCC会告警

1531
01:02:46,740 --> 01:02:51,670
但是如果把这替代成\"  这也替代成\"

1532
01:02:51,930 --> 01:02:54,460
这样  我就有"  \"

1533
01:02:57,110 --> 01:02:58,600
这两个引号就可以显示出来了

1534
01:02:58,600 --> 01:03:00,740
如果你有拿不准的字符

1535
01:03:00,740 --> 01:03:02,700
可能就要用到转义字符了

1536
01:03:02,900 --> 01:03:05,960
如果你想输出一个反斜杠  估计又得迷糊了

1537
01:03:06,120 --> 01:03:07,410
实际上  你不能直接用\

1538
01:03:07,410 --> 01:03:09,060
而是要\\

1539
01:03:09,310 --> 01:03:11,930
否则一个\可能会被误认为

1540
01:03:11,930 --> 01:03:13,120
是转义字符

1541
01:03:13,300 --> 01:03:15,010
还有\0

1542
01:03:15,270 --> 01:03:17,730
用于存储器中字符串末尾

1543
01:03:17,730 --> 01:03:19,720
表示在此之后就

1544
01:03:19,720 --> 01:03:21,090
没有字符了

1545
01:03:21,360 --> 01:03:22,760
不要过于纠结于这些数学问题了

1546
01:03:22,980 --> 01:03:26,160
在计算机领域  你会很讨厌那些

1547
01:03:26,160 --> 01:03:28,600
在这上面钻牛角尖的人  但是对于那些

1548
01:03:28,600 --> 01:03:31,320
像循环这样的逻辑结构又是很有用的

1549
01:03:31,380 --> 01:03:33,400
在C语言还有一些其他

1550
01:03:33,400 --> 01:03:34,410
编程语言里有很多数学符号

1551
01:03:34,690 --> 01:03:37,350
其中很多都不需要加以说明的  像加号

1552
01:03:37,470 --> 01:03:40,450
减号 乘号 除号和(谁能回答?)

1553
01:03:40,450 --> 01:03:41,800
【听不清】

1554
01:03:41,800 --> 01:03:43,480
>>取余符号

1555
01:03:43,480 --> 01:03:44,930
这里有一些细微的区别

1556
01:03:44,930 --> 01:03:46,160
在以后我们会用到

1557
01:03:46,410 --> 01:03:48,800
%给你的是余数

1558
01:03:48,800 --> 01:03:52,880
举个例子  11除以10

1559
01:03:53,120 --> 01:03:55,300
得1余1

1560
01:03:55,680 --> 01:03:59,230
如果在编程里就是11%10

1561
01:03:59,600 --> 01:04:02,440
返回1

1562
01:04:02,440 --> 01:04:05,290
因为1是这个计算式的余数

1563
01:04:05,290 --> 01:04:07,920
当然还有一些其他用途

1564
01:04:07,920 --> 01:04:08,920
不单单是取余数

1565
01:04:09,100 --> 01:04:10,540
如果我们要将某些东西首尾连在一起

1566
01:04:10,540 --> 01:04:13,710
在这个圈里循环  你就会看到它的奇妙之处了  譬如

1567
01:04:13,710 --> 01:04:14,930
你在字母表末

1568
01:04:15,260 --> 01:04:17,290
(在它的帮助下又可以回到字母表头了)

1569
01:04:17,600 --> 01:04:18,930
好  我么继续  这些变量都是些什么?

1570
01:04:18,930 --> 01:04:20,890
在C语言还有其他一些编程语言里

1571
01:04:21,130 --> 01:04:24,290
都会有一大堆

1572
01:04:24,290 --> 01:04:26,640
固定的变量类型

1573
01:04:27,170 --> 01:04:31,020
在C语言里的  和在PHP

1574
01:04:31,020 --> 01:04:33,690
JavaScript里的  是不一样的  至少没那么严格

1575
01:04:33,900 --> 01:04:36,960
在C语言里  在你给变量赋值前

1576
01:04:37,280 --> 01:04:40,250
你必须清楚它的数据类型

1577
01:04:40,250 --> 01:04:43,580
因为C语言能够提供给你

1578
01:04:43,620 --> 01:04:46,020
访问电脑硬盘的权限是很低的

1579
01:04:46,060 --> 01:04:48,640
你必须先告诉你的程序你要用到的变量类型

1580
01:04:48,880 --> 01:04:50,920
这样操作系统才能知道

1581
01:04:50,920 --> 01:04:52,050
分配多少内存给你

1582
01:04:52,270 --> 01:04:55,260
我之前提到过  就是这么点权限

1583
01:04:55,350 --> 01:04:58,660
也能带来很多乐趣  还有一些安全方面的东西

1584
01:04:58,660 --> 01:04:59,770
因为即使是在这么低的权限下

1585
01:04:59,770 --> 01:05:00,730
你也能熟练控制电脑的存储器

1586
01:05:00,730 --> 01:05:03,680
你就可以窃取别人的秘密

1587
01:05:03,680 --> 01:05:05,360
如果知道相应数据位于哪里的话

1588
01:05:05,360 --> 01:05:06,300
你也能窃取别人的数据

1589
01:05:06,470 --> 01:05:08,610
以后我会提到更多这方面的问题

1590
01:05:08,880 --> 01:05:12,500
C语言里有很多数据类型

1591
01:05:12,680 --> 01:05:14,820
但是我们用的最多的 最有用的是

1592
01:05:14,820 --> 01:05:16,100
char型

1593
01:05:16,370 --> 01:05:18,240
如果你想储存一个

1594
01:05:18,440 --> 01:05:19,560
用户敲入的字符

1595
01:05:19,560 --> 01:05:21,900
这个变量就可以定义为char型

1596
01:05:22,260 --> 01:05:25,720
float 是浮点型数据  有点像实数

1597
01:05:25,720 --> 01:05:27,730
即少数点后还有数字的数据

1598
01:05:28,020 --> 01:05:31,890
它很小的  只需32比特就可以了

1599
01:05:32,040 --> 01:05:35,040
double也是一个浮点型数据

1600
01:05:35,220 --> 01:05:36,830
只不过有浮点数据两倍的存储空间

1601
01:05:37,070 --> 01:05:39,210
关于char还有一个重点:一个char占据多大内存

1602
01:05:39,210 --> 01:05:42,750
这个问题我们已经翻来覆去说了好多遍了

1603
01:05:43,890 --> 01:05:45,080
这是一个char  这是一个char

1604
01:05:45,080 --> 01:05:46,850
那么这里的一个方框几比特呢?

1605
01:05:47,550 --> 01:05:47,870
>> 八

1606
01:05:47,870 --> 01:05:49,730
>> 8比特  即1个字节

1607
01:05:50,110 --> 01:05:53,380
一个char型数据占据1字节或8比特

1608
01:05:53,380 --> 01:05:55,880
这是约定  对于大多数

1609
01:05:55,880 --> 01:05:58,270
电脑  当你写代码要用到一个char型数据时

1610
01:05:58,480 --> 01:06:01,770
必须先预留8比特或1字节

1611
01:06:01,820 --> 01:06:03,260
的空间来存储这个char型数据

1612
01:06:03,460 --> 01:06:07,010
这是很有用的  尤其是在法庭上

1613
01:06:07,120 --> 01:06:08,700
查看硬盘驱动器里的数据时

1614
01:06:08,890 --> 01:06:10,260
如果你连

1615
01:06:10,260 --> 01:06:13,750
文件有多少比特都不知道  你如何去恢复数据

1616
01:06:13,800 --> 01:06:16,270
获取你想要的信息呢

1617
01:06:16,480 --> 01:06:22,270
而float就不只1字节了  它占据4个字节  或者说32比特

1618
01:06:22,760 --> 01:06:28,570
32比特的浮点型数据精度更大

1619
01:06:28,920 --> 01:06:31,080
一个浮点型数据就是一个

1620
01:06:31,080 --> 01:06:32,710
带小数点的数

1621
01:06:32,850 --> 01:06:33,500
规定而已

1622
01:06:33,500 --> 01:06:35,520
可以小数点前面长  后面短

1623
01:06:35,750 --> 01:06:37,480
或者  前面短  后面长

1624
01:06:37,600 --> 01:06:39,530
因为只有有限个比特

1625
01:06:39,530 --> 01:06:42,900
今天的重点就是  它就这么点精度

1626
01:06:42,900 --> 01:06:45,400
在当今世界  大多数情况下

1627
01:06:45,400 --> 01:06:48,670
并不是要把每个数字

1628
01:06:48,670 --> 01:06:50,050
都精确表示出来

1629
01:06:50,110 --> 01:06:52,490
你可能会碰到一些无限的值

1630
01:06:52,650 --> 01:06:54,740
如果你只有有限的空间

1631
01:06:54,770 --> 01:06:57,270
废话  电脑当然只有一个有限的磁盘空间

1632
01:06:57,270 --> 01:06:59,390
或RAM  我们得做一些近似处理

1633
01:06:59,660 --> 01:07:00,400
结果可能是

1634
01:07:00,400 --> 01:07:02,590
近似处理的相当不错

1635
01:07:02,590 --> 01:07:04,600
当然是对于一些小项目来说

1636
01:07:04,830 --> 01:07:06,670
但如果你碰到涉及科学研究

1637
01:07:06,710 --> 01:07:09,210
或财政方面的项目时  不精确度

1638
01:07:09,210 --> 01:07:11,830
和错误就会累加

1639
01:07:11,830 --> 01:07:16,070
你们可能已经在Superman 3和Office Space见识过

1640
01:07:16,070 --> 01:07:19,210
这些骗局就是通过这个方法从金融市场上

1641
01:07:19,210 --> 01:07:21,130
一分一厘地窃取钱财的

1642
01:07:21,520 --> 01:07:23,610
这类问题已经日趋严重了

1643
01:07:23,860 --> 01:07:25,910
由于他们使用的语言或电脑

1644
01:07:25,910 --> 01:07:27,260
都是精度有限的

1645
01:07:27,260 --> 01:07:28,430
因此存在这样的问题

1646
01:07:28,430 --> 01:07:31,380
所以在办公地点里的家伙才能够搞到钱

1647
01:07:31,380 --> 01:07:32,950
然后利滚利--很快的方法--

1648
01:07:33,030 --> 01:07:35,550
这就是整个影片的亮点  当他们出于极度兴奋之中

1649
01:07:35,550 --> 01:07:37,320
因为他们已经一夜之间

1650
01:07:37,320 --> 01:07:38,420
变成百万富翁了

1651
01:07:38,740 --> 01:07:40,040
呵呵  我们扯得有点远了

1652
01:07:40,320 --> 01:07:43,570
除了这三种类型外  还有一种最原始的数据类型  int

1653
01:07:43,570 --> 01:07:46,310
32比特整数

1654
01:07:46,400 --> 01:07:48,780
而对于32比特

1655
01:07:48,780 --> 01:07:50,740
所能表示的最大的数是多少?

1656
01:07:50,870 --> 01:07:56,420
就是2的32次方  因为1比特只能表示0或1

1657
01:07:56,420 --> 01:07:59,190
如果有32比特的话  每个比特都有0或

1658
01:07:59,440 --> 01:08:01,280
两种可能性

1659
01:08:01,280 --> 01:08:03,340
所以是2的32次方  也就是40亿

1660
01:08:03,690 --> 01:08:07,530
只要有一个整数  一个int型的数据  就能储存任意一个

1661
01:08:07,530 --> 01:08:09,850
位于0到40亿之间的一个数

1662
01:08:10,060 --> 01:08:13,180
或者你想储存一个负数  就必须位于负20亿到

1663
01:08:13,180 --> 01:08:15,730
正20亿之间  是个有限的范围

1664
01:08:15,730 --> 01:08:18,500
但实际上  这是有问题的

1665
01:08:18,760 --> 01:08:22,580
在Facebook创立之初

1666
01:08:23,030 --> 01:08:26,760
我猜他们使用int来表示配置文件ID

1667
01:08:26,940 --> 01:08:28,880
但是如果你看过最近的【听不见】

1668
01:08:29,040 --> 01:08:32,350
如果你访问了最近在Facebook上留言的朋友

1669
01:08:32,350 --> 01:08:34,970
你会发现  可以从URL上看到他们的配置文件ID

1670
01:08:34,970 --> 01:08:37,110
很长很长  那是因为

1671
01:08:37,140 --> 01:08:39,360
可能在某个时间点  他们已经过渡到

1672
01:08:39,360 --> 01:08:44,220
64比特了  也就是所谓的longlong

1673
01:08:44,220 --> 01:08:47,930
这样他们就能有很多的用户ID了

1674
01:08:47,930 --> 01:08:51,660
倒不是因为他们有成千上万的用户

1675
01:08:51,880 --> 01:08:53,970
而是创建账户来引导其他账户

1676
01:08:53,970 --> 01:08:55,950
其实他们完全没有必要以这种方式复用

1677
01:08:56,200 --> 01:08:57,980
所以说  我可能说的都不对

1678
01:08:58,080 --> 01:08:59,860
但是我认为现在恐怕已经有64位了

1679
01:09:00,020 --> 01:09:01,780
大家可以自己去看一下

1680
01:09:02,260 --> 01:09:04,760
我们还是回到这里  还有两种很有用的数据类型

1681
01:09:04,760 --> 01:09:06,550
这两种都不用担心内存不足

1682
01:09:06,550 --> 01:09:07,450
一个是bool类型

1683
01:09:07,620 --> 01:09:10,260
我们上周简短地谈论过Bool先生的

1684
01:09:10,260 --> 01:09:13,680
真假的逻辑思想  但是在C语言里  没有布尔数据类型

1685
01:09:13,680 --> 01:09:15,700
也就没有真或假

1686
01:09:15,980 --> 01:09:18,640
我们得用0或1来伪造

1687
01:09:18,880 --> 01:09:20,590
这么说有点粗野

1688
01:09:20,590 --> 01:09:22,480
我要接着讲的是这种抽象的思想

1689
01:09:22,480 --> 01:09:26,750
或者用这个来描绘设计出

1690
01:09:26,750 --> 01:09:29,520
真和假的思想

1691
01:09:29,520 --> 01:09:31,900
我们可以给真假各指定一个同义词

1692
01:09:31,950 --> 01:09:34,660
当然我们不能随便就说0就是假

1693
01:09:34,700 --> 01:09:35,770
1就是真

1694
01:09:36,090 --> 01:09:39,730
实际上  你可以用C语言中的特定的语法

1695
01:09:39,730 --> 01:09:41,990
你们懂得  虽然到最后

1696
01:09:41,990 --> 01:09:45,860
我把0当成假  1当成真来看

1697
01:09:46,140 --> 01:09:48,880
我们也可以从这些细节中抽象出来

1698
01:09:48,880 --> 01:09:51,310
使用像"真""假"这样更直观的词

1699
01:09:51,560 --> 01:09:54,130
这堂课开始的时候  我给大家看过一个无限循环的小程序

1700
01:09:54,130 --> 01:09:56,120
里面就有一个while(true)

1701
01:09:56,450 --> 01:09:59,520
true就是我们自己插入进去的

1702
01:09:59,560 --> 01:10:01,950
当然前提是假设你们包括了CS50库

1703
01:10:02,200 --> 01:10:03,840
>> 在其他的语言  譬如C++

1704
01:10:03,840 --> 01:10:06,560
Java 就有bool型数据

1705
01:10:06,780 --> 01:10:08,920
字符串  就是另外一个善意的谎言

1706
01:10:08,920 --> 01:10:11,690
迄今为止  我们用字符串来接受用户的输入

1707
01:10:11,690 --> 01:10:12,650
然后存储在变量里

1708
01:10:12,930 --> 01:10:14,910
字符串在C语言里其实不是一种数据类型

1709
01:10:14,910 --> 01:10:20,910
而是一种称为char *的数据类型

1710
01:10:20,910 --> 01:10:22,880
这个知识点我以后会讲到

1711
01:10:22,880 --> 01:10:24,060
正如我们看到的

1712
01:10:24,430 --> 01:10:25,980
一个字符就是一个单独的字符

1713
01:10:26,190 --> 01:10:28,810
就是所谓的指针

1714
01:10:28,810 --> 01:10:33,920
所以string并不完全是我在这儿描述的这样

1715
01:10:33,920 --> 01:10:36,350
当我说字符串时

1716
01:10:36,630 --> 01:10:38,860
我并不是指这些字符集

1717
01:10:39,120 --> 01:10:43,010
而是指地址  就是这些字符集在存储器中的位置

1718
01:10:43,050 --> 01:10:46,680
之前讲的有点乏味  但是  高潮就要来了

1719
01:10:46,980 --> 01:10:50,860
这个图表  看起来很烦  很无趣  但是它很有用

1720
01:10:50,860 --> 01:10:52,040
上面

1721
01:10:52,080 --> 01:10:55,380
有非常明确的规定

1722
01:10:55,380 --> 01:10:57,790
譬如  当你写代码时

1723
01:10:57,850 --> 01:10:59,980
就会涉及操作符的优先级

1724
01:10:59,980 --> 01:11:02,030
你们可能会想起小学时  将一些加法表达式

1725
01:11:02,030 --> 01:11:04,380
放在圆括号里  这样加法可以先计算

1726
01:11:04,380 --> 01:11:05,530
然后是乘法

1727
01:11:05,530 --> 01:11:07,750
否则  乘法默认先发生

1728
01:11:07,980 --> 01:11:10,580
同样  在像C语言这样的编程语言里  也有

1729
01:11:10,580 --> 01:11:12,130
一套非常明确的规则

1730
01:11:12,130 --> 01:11:13,420
这些都在推荐图书里面

1731
01:11:13,420 --> 01:11:14,730
网上也有很多资源 我之所以提这个

1732
01:11:14,950 --> 01:11:17,410
是想告诉大家如果你对某些式子的前后运算关系不确定

1733
01:11:17,940 --> 01:11:20,760
就加上括号

1734
01:11:21,050 --> 01:11:24,130
这都是一些小细节

1735
01:11:24,130 --> 01:11:25,640
我们以后还是会再提到的

1736
01:11:26,020 --> 01:11:29,680
这堂课最后

1737
01:11:30,170 --> 01:11:32,880
如果我们只是看几个小程序  根本没啥用

1738
01:11:32,880 --> 01:11:34,730
还不如hello world程序呢

1739
01:11:34,730 --> 01:11:36,520
这里有很多其他结构类型如循环控制

1740
01:11:36,520 --> 01:11:39,080
条件分支等等  所以我觉得应该

1741
01:11:39,390 --> 01:11:41,490
以这个程序作为结束

1742
01:11:41,980 --> 01:11:45,350
我们来讨论一下这个中心对称的程序

1743
01:11:45,350 --> 01:11:46,970
这程序写出来的结果很漂亮

1744
01:11:46,970 --> 01:11:49,840
完全按照美学角度摆放

1745
01:11:50,180 --> 01:11:54,160
说的有点不对

1746
01:11:54,510 --> 01:11:56,600
这代码写出来有点像--

1747
01:11:56,740 --> 01:11:58,540
我不确定这像什么

1748
01:11:58,540 --> 01:12:00,640
像朵花  或纸风车  或其他什么东西

1749
01:12:00,930 --> 01:12:02,940
这只是语法上说得通

1750
01:12:02,940 --> 01:12:06,420
这些分号放在它应该放的地方

1751
01:12:06,730 --> 01:12:11,070
我不确定这到底写的是什么  但是--

1752
01:12:11,070 --> 01:12:13,440
看一下这些你们熟悉的结构  有if啊  while啊

1753
01:12:13,440 --> 01:12:15,760
for啊  这些东西我们以后会

1754
01:12:15,760 --> 01:12:16,610
大量接触到

1755
01:12:16,790 --> 01:12:17,990
我们先编译一下

1756
01:12:18,020 --> 01:12:22,410
这个就是那个很混乱的C语言比赛

1757
01:12:22,410 --> 01:12:24,530
这并不是我们要去的比赛  你们可以根据爱好决定参不参加

1758
01:12:24,890 --> 01:12:26,820
我们接着编译

1759
01:12:26,820 --> 01:12:29,160
很多错误  但是这条  我们之前见过

1760
01:12:29,160 --> 01:12:31,510
未定义的引用  上次我们是怎么解决的呢?

1761
01:12:32,050 --> 01:12:32,390
>>库

1762
01:12:32,630 --> 01:12:33,440
>>缺少库

1763
01:12:33,440 --> 01:12:35,480
似乎有一些我们还未见过的库

1764
01:12:35,480 --> 01:12:36,760
其中一个就是math库

1765
01:12:36,980 --> 01:12:39,860
你们可能会说  /lmath  其实可以简化

1766
01:12:39,920 --> 01:12:41,900
因为使用太广泛了 一般都简化为/lm

1767
01:12:41,980 --> 01:12:44,130
对于这个程序

1768
01:12:44,130 --> 01:12:45,480
凭经验来讲

1769
01:12:45,730 --> 01:12:47,650
应该还需要一个Ncurses库

1770
01:12:47,650 --> 01:12:51,450
这是一个--绘画用的库

1771
01:12:51,450 --> 01:12:53,050
可以让我们在屏幕上画图案

1772
01:12:53,270 --> 01:12:57,830
把所有的库都连接起来  重新编译  就好了

1773
01:12:57,830 --> 01:13:00,620
运行a out

1774
01:13:00,620 --> 01:13:03,490
这周五的亮点就是--这个高潮(画面)

1775
01:13:03,490 --> 01:13:04,740
【听不清】

1776
01:13:04,740 --> 01:13:06,280
>> 我知道

1777
01:13:06,430 --> 01:13:16,830
这周五见

1778
01:13:16,830 --> 01:13:18,760
【听不见的讨论声】

1779
01:13:18,760 --> 01:13:20,700
【音乐】

