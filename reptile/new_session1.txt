1
00:00:10,130 --> 00:00:13,320
>> 大卫:欢迎回到CS50课程
2
00:00:13,320 --> 00:00:14,950
也欢迎你们正式登记加入我们
3
00:00:14,950 --> 00:00:17,090
这是第一周最后一课
4
00:00:17,470 --> 00:00:19,790
登记加入我们的人数在这里
5
00:00:19,790 --> 00:00:21,770
并且我们觉得我们能分享一些统计资料
6
00:00:21,770 --> 00:00:24,600
我们在这次课程中也喜欢这么做 作为计算机科学家
7
00:00:24,600 --> 00:00:25,970
我们要收集很多数据
8
00:00:26,230 --> 00:00:29,100
我不想用最初你们想到的图表形式
9
00:00:29,360 --> 00:00:33,350
而是通过CS50的程序风格来展示这些数据
10
00:00:33,350 --> 00:00:35,920
我写了一个叫做"图表"的小程序
11
00:00:35,920 --> 00:00:38,360
基于我在程序中硬编码的一些数据
12
00:00:38,360 --> 00:00:41,160
向我们显示在过去几年中我们课程的人数
13
00:00:41,400 --> 00:00:43,400
在这里你们没看到我所看到的
14
00:00:43,400 --> 00:00:44,660
因为我还么有点击这个按钮
15
00:00:44,930 --> 00:00:46,480
但是现在你们的确看到了
16
00:00:46,480 --> 00:00:48,310
我设计了一个终端窗口
17
00:00:48,310 --> 00:00:52,380
所以我在网站cloud CS50 net植入了一个叫做"SSH'd"的东西
18
00:00:52,380 --> 00:00:54,800
我已经通过我的电脑连接到了课程的中心服务器
19
00:00:54,800 --> 00:00:58,110
在我的笔记本电脑上  通过键入" /chart"
20
00:00:58,110 --> 00:01:01,920
我将要运行一个被描写成
21
00:01:01,920 --> 00:01:03,930
"ASCII码艺术"的小程序
22
00:01:04,010 --> 00:01:06,920
在一个这样的终端窗口中你们都可以做到--
23
00:01:07,170 --> 00:01:09,140
过去几年中我们的人数
24
00:01:09,140 --> 00:01:18,500
所以我们有2007年  2008年  2009年和"bang(感叹)"--
25
00:01:18,550 --> 00:01:19,570
这就是你们的人数
26
00:01:19,570 --> 00:01:22,230
我们真的非常高兴  因为有你们参加了
27
00:01:22,230 --> 00:01:23,270
这个学期的这个课程
28
00:01:23,270 --> 00:01:24,950
匆匆扫一眼过去  的确好像
29
00:01:24,950 --> 00:01:27,890
今天大约有225个人还在睡觉
30
00:01:28,230 --> 00:01:30,130
不过那也挺好
31
00:01:30,130 --> 00:01:33,400
这将是我们周五最后一个演讲 以后会回到周一
32
00:01:33,400 --> 00:01:34,490
和周三上课
33
00:01:34,710 --> 00:01:36,560
不过这的确让人非常满意了
34
00:01:36,560 --> 00:01:37,570
对于我们教员来说
35
00:01:37,570 --> 00:01:39,670
你们也认识到了  因为我们
36
00:01:39,860 --> 00:01:41,760
在过去几年中作出了共同的努力
37
00:01:41,760 --> 00:01:43,490
来影响这个校园的学生们
38
00:01:43,720 --> 00:01:46,630
但是某些学生可能认为这并不是一个探索性的领域
39
00:01:46,630 --> 00:01:48,780
而只是学期中的一个课程而已
40
00:01:48,780 --> 00:01:51,800
或者只是一门主修或选修课程
41
00:01:51,800 --> 00:01:54,860
所以我对你们承诺  也是所有教员的承诺:
42
00:01:54,860 --> 00:01:58,080
你们绝对能够通过这门课程
43
00:01:58,080 --> 00:02:00,110
并且在课程中度过一个愉快的时光
44
00:02:00,110 --> 00:02:02,190
我给你们分享另外几个有趣的事实--
45
00:02:02,190 --> 00:02:04,300
在下周  一旦我们看到你们的习题集上是
46
00:02:04,680 --> 00:02:07,090
"零个意见书"  如果你们还没有填写那个习题集的话
47
00:02:07,090 --> 00:02:08,880
你们可以问一些人数统计方面的问题
48
00:02:08,880 --> 00:02:12,440
或一些古怪的问题  那样我们就能对学生有个初步的了解
49
00:02:13,910 --> 00:02:16,750
刚才我们在这个课程中作了一个分类
50
00:02:16,750 --> 00:02:17,860
从往年数据上可以看出
51
00:02:17,870 --> 00:02:19,440
上这个课程的大都是大学二年级的学生
52
00:02:19,440 --> 00:02:22,620
可能跟当时的我一样  开始认识到我们终于有时间
53
00:02:22,620 --> 00:02:24,500
来探究我们兴趣以外的事情
54
00:02:24,700 --> 00:02:26,090
不过这是个相当不错的分类
55
00:02:26,090 --> 00:02:27,090
如果你觉得你是这门课程中的
56
00:02:27,090 --> 00:02:30,090
唯一的一个毕业班的学生:那你们错了
57
00:02:30,090 --> 00:02:32,450
这里有大约一百个毕业班的学生  大约一百个大三的学生
58
00:02:32,730 --> 00:02:34,340
一两百个大二的学生
59
00:02:34,340 --> 00:02:35,830
还有大约一百个大一的新生
60
00:02:35,830 --> 00:02:37,230
所以这是个相当不错的人数统计
61
00:02:37,400 --> 00:02:38,980
在这里我们也有来自
62
00:02:38,980 --> 00:02:40,720
设计学院 艺术与科学学院的研究生
63
00:02:40,720 --> 00:02:43,390
这里有90个来自哈佛开放学院的学生
64
00:02:43,390 --> 00:02:45,710
他们正在通过远程教育来学习这门课程
65
00:02:45,710 --> 00:02:47,910
所以参加2010年CS50课程的团体是很庞大的
66
00:02:47,990 --> 00:02:51,570
刚才你们看到的图片显示的是
67
00:02:51,570 --> 00:02:54,260
2009年的数据
68
00:02:54,300 --> 00:02:56,940
我们非常高兴的说  在CS50课程上我们虽然没有50%的女生
69
00:02:57,210 --> 00:03:00,800
但现在已经达到了38%
70
00:03:00,800 --> 00:03:03,060
这是21年来最高的比例
71
00:03:03,060 --> 00:03:07,970
欢迎你们加入CS50课程  女士们
72
00:03:08,230 --> 00:03:13,570
我们上次讲到了查看一些代码
73
00:03:13,570 --> 00:03:15,510
并且给你们带来这下面的习题
74
00:03:15,720 --> 00:03:19,190
所以在接下来的一周  我们将考虑支撑结构
75
00:03:19,450 --> 00:03:21,700
我们不会留给大家一些知识片段--
76
00:03:21,910 --> 00:03:24,600
所以这周末或下周一开始讨论这方面的内容
77
00:03:24,600 --> 00:03:26,990
根据这次的登记信息  我们将
78
00:03:26,990 --> 00:03:28,720
对之前我们记住的时间表进行修改
79
00:03:28,720 --> 00:03:31,180
我们会通过邮件通知大家  我们有你们
80
00:03:31,390 --> 00:03:32,800
正式哈佛邮箱地址的存档--
81
00:03:33,030 --> 00:03:34,820
在接下来几天内我们会给大家发邮件
82
00:03:34,820 --> 00:03:37,590
根据到大家的方便程度等  来对时间表进行正式地划分安排
83
00:03:37,880 --> 00:03:40,280
但对于这一周  我们已经有了一个合适的支撑结构
84
00:03:40,380 --> 00:03:43,030
我们有一个叫做"超级时间表"的东西
85
00:03:43,030 --> 00:03:45,270
这对于各种方便程度的学生们来说都是愿意接受的
86
00:03:45,500 --> 00:03:47,230
我们有三门不同的课程  分别在这周天
87
00:03:47,230 --> 00:03:48,340
周一和周二开讲
88
00:03:48,620 --> 00:03:50,430
请核对一下"时间表"下面的网站中的
89
00:03:50,430 --> 00:03:52,370
时间和地点
90
00:03:52,620 --> 00:03:54,700
其中一门课程也会被拍成录像
91
00:03:54,920 --> 00:03:56,990
所以你们万一没有时间也不用担心
92
00:03:56,990 --> 00:03:59,480
那个视频在周二会放到网上去
93
00:03:59,480 --> 00:04:01,940
直到周五过期  这其中还是有充裕的时间的
94
00:04:02,230 --> 00:04:04,120
我们这周天开始"代码走查"
95
00:04:04,330 --> 00:04:06,090
这个会由研究生助教带领大家
96
00:04:06,090 --> 00:04:08,200
什么叫做"走查"  然后这是一种
97
00:04:08,200 --> 00:04:09,430
编程词库
98
00:04:09,700 --> 00:04:13,400
"代码走查"的概念是单独或者和别人一起
99
00:04:13,400 --> 00:04:15,390
通过查看或讨论学习你们的代码
100
00:04:15,390 --> 00:04:16,750
的一个过程
101
00:04:16,750 --> 00:04:20,310
我们通过CS50课程的代码走查来达到解决
102
00:04:20,310 --> 00:04:22,100
每周习题集的目的
103
00:04:22,100 --> 00:04:24,180
大家要以所谓的标准版为目标
104
00:04:24,180 --> 00:04:25,730
我希望大部分同学会这么做
105
00:04:25,970 --> 00:04:28,310
黑客版--我们不会提供走查的细节
106
00:04:28,310 --> 00:04:30,370
因为我们假设大家都准备好了
107
00:04:30,370 --> 00:04:31,850
独立地投入到PDF中
108
00:04:32,070 --> 00:04:35,120
但对于大多数学生来说  知道这个资源是存在的
109
00:04:35,430 --> 00:04:37,210
我觉得这会有很大的益处的
110
00:04:37,210 --> 00:04:39,910
通过最低限度地阅读PDF文档
111
00:04:39,910 --> 00:04:41,330
大家会收获很多经验
112
00:04:41,590 --> 00:04:42,660
这的确是一个机会
113
00:04:42,660 --> 00:04:45,190
特别对于那些不怎么舒适的  这是通过
114
00:04:45,190 --> 00:04:46,300
特殊途径开始的好机会
115
00:04:46,570 --> 00:04:49,490
所以你们不要拿起一篇上面一大堆的希腊语文档
116
00:04:49,490 --> 00:04:51,200
或者对你来说那像是希腊语  然后想知道:
117
00:04:51,200 --> 00:04:52,270
"我该从哪里开始?"
118
00:04:52,390 --> 00:04:53,420
我的意思是  我们会带着你们开始的
119
00:04:53,420 --> 00:04:56,470
这就是为那些每周剩余的习题集
120
00:04:56,470 --> 00:04:57,870
而打好基础的
121
00:04:58,070 --> 00:05:01,700
这周日晚上7:00  核对下"习题集"下面的
122
00:05:01,700 --> 00:05:04,160
网站中的地址
123
00:05:04,460 --> 00:05:04,970
好的
124
00:05:05,430 --> 00:05:07,750
今天我们将要写一些程序  并且让你们
125
00:05:07,750 --> 00:05:12,290
在接下来的一周写你们自己的程序  今天晚上七点
126
00:05:12,290 --> 00:05:15,160
习题集1会发布在网站上
127
00:05:15,210 --> 00:05:16,750
所以如何来写一个程序呢
128
00:05:16,750 --> 00:05:18,160
这分为三个步骤
129
00:05:18,160 --> 00:05:19,750
你先打开那个"文本编辑器"
130
00:05:20,010 --> 00:05:22,560
就是我们周三用过的叫做Nano的编辑器
131
00:05:22,560 --> 00:05:24,590
这个跟写字板和记事本差不多--
132
00:05:24,820 --> 00:05:27,390
非常简单的  只是通过一种有用的方法而进行精简了的
133
00:05:27,600 --> 00:05:29,540
所以你们可以把注意力集中在编写代码上
134
00:05:29,540 --> 00:05:30,890
而不需要学习一些新的界面操作
135
00:05:31,130 --> 00:05:34,240
我们需要记忆的 用的比较多的命令有:
136
00:05:34,240 --> 00:05:37,730
CTRL+X是用来保存退出的  CTRL+O是用来保存的
137
00:05:37,980 --> 00:05:40,680
你们可以在这里和网上一些教材上
138
00:05:40,680 --> 00:05:42,650
看到一些其他的快捷键
139
00:05:42,650 --> 00:05:43,840
那样会节约我们很多时间
140
00:05:44,060 --> 00:05:45,220
如果你们有谁想使用
141
00:05:45,220 --> 00:05:48,020
更高级点的文本编辑器的话  我们可以给你们
142
00:05:48,020 --> 00:05:51,760
一些指导:像Vim   或者Vi   Emacs编辑器
143
00:05:51,760 --> 00:05:54,310
还有一些其他的客户端编辑软件
144
00:05:54,370 --> 00:05:55,870
我们也授权给 你们使用
145
00:05:55,930 --> 00:05:57,660
所有的一切将会到来
146
00:05:57,740 --> 00:05:59,740
不过一旦你们写了一个"hello world"程序
147
00:05:59,740 --> 00:06:02,250
并且把它保存为hello c文件后退出
148
00:06:02,910 --> 00:06:06,160
然后你们运行编译器  在这里我们使用叫做"GCC"的编译器--
149
00:06:06,160 --> 00:06:07,440
这是全球最流行的--
150
00:06:07,620 --> 00:06:10,060
然后你们可以通过一些命令来运行这个编译器
151
00:06:10,200 --> 00:06:12,680
这些命令行参数可以
152
00:06:12,930 --> 00:06:15,570
影响这个程序的行为
153
00:06:15,850 --> 00:06:19,050
所以这个命令  在这里的第二个--
154
00:06:19,050 --> 00:06:20,800
你们谁能快速地把它翻译成
155
00:06:20,800 --> 00:06:24,640
英语来说明这是干什么的吗? 请说?
156
00:06:25,210 --> 00:06:26,810
>>运行程序【无法辨认的声音】
157
00:06:27,180 --> 00:06:29,900
然后把它保存为"hello"文件--
158
00:06:31,820 --> 00:06:32,300
>>大卫:好的  不错
159
00:06:32,300 --> 00:06:34,420
差不多是的 我再补充一点
160
00:06:34,420 --> 00:06:37,380
GCC正在编译我们刚才写的代码
161
00:06:37,380 --> 00:06:41,450
在这个文件中--
162
00:06:41,450 --> 00:06:43,110
这个--哦  没错
163
00:06:43,110 --> 00:06:45,900
好的  我先把这个改正过来再来补充吧
164
00:06:47,220 --> 00:06:47,780
我们继续
165
00:06:48,470 --> 00:06:51,890
这个GCC将编译我们刚才在hello c文件中的
166
00:06:51,890 --> 00:06:53,870
源代码
167
00:06:54,150 --> 00:06:57,130
我们不希望获得一个默认的很挫的名字"a out"
168
00:06:57,360 --> 00:07:00,760
我先用这个命令"-o"来输出  然后文件名"hello"
169
00:07:00,820 --> 00:07:03,220
它实际上存储的是"1"和"0"
170
00:07:03,220 --> 00:07:05,860
存储在一个叫做"hello"的比较贴切的名字的文件中
171
00:07:05,860 --> 00:07:06,710
而不是叫做"a out"的一个文件
172
00:07:06,820 --> 00:07:07,940
现在有些人可能会问:
173
00:07:07,940 --> 00:07:10,610
为什么我在用"cs50"结尾时  又在它之前
174
00:07:10,610 --> 00:07:12,020
加了个"-l"命令
175
00:07:13,070 --> 00:07:16,330
>> 那是告诉编译器我们想要在程序库中
176
00:07:16,330 --> 00:07:19,950
使用一些当前的编译后的代码
177
00:07:20,510 --> 00:07:21,000
>> 大卫:嗯  很好
178
00:07:21,120 --> 00:07:25,440
所以那是一个标记  用来告诉编译器我想使用
179
00:07:25,440 --> 00:07:29,520
或连接我自己的程序代码到一个叫做CS50的系统中的程序
180
00:07:29,520 --> 00:07:33,390
可能其他人在那个系统写了这些程序
181
00:07:33,390 --> 00:07:36,170
我们粗略地谈谈或剖析一下三两个其他的命令:
182
00:07:36,380 --> 00:07:39,350
如果你们想用数学程序库  可以加上"-lm"
183
00:07:39,350 --> 00:07:42,520
在那里我们有sin cos和圆周率和其他的函数
184
00:07:42,520 --> 00:07:44,430
你们以后可能需要用到
185
00:07:44,430 --> 00:07:46,390
但我还需要指出的是
186
00:07:46,900 --> 00:07:49,940
我们粗略讲解一下  这里有一个"-lncurses"命令
187
00:07:49,940 --> 00:07:51,690
那是一个简单的图像程序库
188
00:07:51,690 --> 00:07:53,330
它在周三末尾做了个时髦的东西
189
00:07:53,330 --> 00:07:54,640
还有些很多其他的命令
190
00:07:54,680 --> 00:07:59,200
但现在如果你删除"-lcs50"
191
00:07:59,200 --> 00:08:00,980
你们会得到一些提示--一些错误信息--
192
00:08:00,980 --> 00:08:03,810
像"未定义的符号"  这可以为你提过线索
193
00:08:03,980 --> 00:08:06,780
"这个没有被定义  我没有告诉编译器
194
00:08:06,890 --> 00:08:08,900
把想把这个与"1"和"0"建立连接 "
195
00:08:08,900 --> 00:08:10,860
那最后  这三个命令式做什么的呢?
196
00:08:11,370 --> 00:08:12,970
>> 运行程序
197
00:08:13,040 --> 00:08:13,510
>> 大卫:运行程序
198
00:08:13,510 --> 00:08:16,230
" /hello"是用来运行程序的  我们经常看到的
199
00:08:16,230 --> 00:08:18,760
如果你省略--作为一点提醒--那个" /"呢?
200
00:08:20,190 --> 00:08:21,630
>> 会发生错误
201
00:08:22,040 --> 00:08:24,060
>> 大卫:会出现一个错误信息像"没找到文件"
202
00:08:24,060 --> 00:08:25,310
或"没找到命令"
203
00:08:25,310 --> 00:08:28,390
那是因为hello c是我所写的东西--
204
00:08:28,390 --> 00:08:30,190
而不是从哪里下载或购买
205
00:08:30,190 --> 00:08:32,140
并通过双击安装的程序
206
00:08:32,140 --> 00:08:33,720
--因为那是我写的程序
207
00:08:34,040 --> 00:08:35,780
在我当前目录下编译的
208
00:08:35,910 --> 00:08:38,080
我们不得不对计算机强调
209
00:08:38,080 --> 00:08:39,510
它是在这个地方的
210
00:08:39,510 --> 00:08:42,930
" "表示的是我当前的工作目录
211
00:08:42,930 --> 00:08:45,200
那个我当前所在的文件中
212
00:08:45,460 --> 00:08:49,020
好的  让我们来写点比"hello world"
213
00:08:49,020 --> 00:08:50,560
更有意思点的程序吧
214
00:08:50,560 --> 00:08:54,680
从你们周三打印出来的资料来看  如果你们手上有的话
215
00:08:54,940 --> 00:08:58,400
你们会看到有个叫做的"math1 c"的文件 如果你们没有资料
216
00:08:58,620 --> 00:09:00,670
那些程序还是比较短的  所以你们应该可以很轻松地
217
00:09:00,670 --> 00:09:02,280
来看这些程序  但是那个PDF文件
218
00:09:02,280 --> 00:09:04,830
和实际的源代码都可以到网上找到
219
00:09:04,830 --> 00:09:05,480
相关的资料
220
00:09:06,340 --> 00:09:09,810
所以根据初步的印象
221
00:09:10,940 --> 00:09:14,740
如果你们运行这个程序  它会做什么? 啊?
222
00:09:15,200 --> 00:09:17,880
>> 它会做加法  像x加y--
223
00:09:18,200 --> 00:09:18,390
>> 大卫:嗯  好的
224
00:09:18,390 --> 00:09:21,550
它把x加上y  再把结果存到z中 但是如果有人
225
00:09:21,550 --> 00:09:23,910
想要做的有点不合常理点呢
226
00:09:23,910 --> 00:09:24,970
那这个程序会做什么?
227
00:09:25,180 --> 00:09:27,180
>> 【无法辨认的声音】
228
00:09:27,340 --> 00:09:27,710
>> 大卫:什么都不做  对不?
229
00:09:27,710 --> 00:09:29,940
实际上  最终它什么都不会做
230
00:09:30,110 --> 00:09:31,380
因为我在演算这个算术
231
00:09:31,590 --> 00:09:33,130
它会在后台运行一些的操作
232
00:09:33,310 --> 00:09:34,730
这对我们来说是有用
233
00:09:34,910 --> 00:09:37,900
结果不是那样的  但这的确有个事实
234
00:09:38,110 --> 00:09:41,030
我们有些基本的运算法则和等号和
235
00:09:41,030 --> 00:09:44,680
其他一些东西  用来为我们一些
236
00:09:44,680 --> 00:09:45,840
更多有用的目的而服务的
237
00:09:46,010 --> 00:09:49,150
让我们快速地看看它到底做了些什么
238
00:09:49,150 --> 00:09:51,280
事实上  其中一个TFs能不能找到那个激光笔?
239
00:09:51,280 --> 00:09:52,870
哦  它在这里
240
00:09:52,960 --> 00:09:56,210
这里的这条线声明了一个变量
241
00:09:56,210 --> 00:09:59,090
一个叫做"x"的存储空间  它的类型是"int"
242
00:09:59,190 --> 00:10:00,960
意思是里面存储的是整数型的数据
243
00:10:01,300 --> 00:10:05,050
那个等号其实是个"赋值运算符"
244
00:10:05,050 --> 00:10:07,960
这样我们还要引入了一个新的操作符
245
00:10:07,960 --> 00:10:10,580
我们将看到这里不仅有一个等号的操作
246
00:10:10,580 --> 00:10:12,340
还有双等号
247
00:10:12,340 --> 00:10:14,270
等下我们会明白它的意思  这只是
248
00:10:14,270 --> 00:10:15,320
因为他们有着不同的含义
249
00:10:15,590 --> 00:10:18,180
通常在这个"C"语言中  像其他的语言一样
250
00:10:18,180 --> 00:10:20,960
几乎所有的你们的代码行都要以分号结束
251
00:10:20,960 --> 00:10:23,880
但不是所有的 只是大部分的
252
00:10:23,880 --> 00:10:24,810
我们将看到他们的区别
253
00:10:24,810 --> 00:10:27,030
恰当的例子:这里没有分号
254
00:10:27,030 --> 00:10:29,470
这里也没有分号  这里也没有
255
00:10:29,690 --> 00:10:32,440
实际上  根据经验  你们回忆一下在Scratch中
256
00:10:32,470 --> 00:10:34,540
任何时候你们写一条语句--
257
00:10:34,720 --> 00:10:37,290
处理一些操作的一行代码--
258
00:10:37,510 --> 00:10:39,160
你们通常需要在那里加个分号
259
00:10:39,200 --> 00:10:40,870
不久后你们就会习惯这个语法
260
00:10:41,140 --> 00:10:42,870
然后我在第二行做了同样的事情
261
00:10:42,870 --> 00:10:44,320
我声明了"y"
262
00:10:44,380 --> 00:10:45,930
并把它赋值为2
263
00:10:46,160 --> 00:10:48,230
然后我声明了一个叫做"z"的变量
264
00:10:48,560 --> 00:10:50,830
把这两个数字加起来  把他们的总数存起来
265
00:10:51,120 --> 00:10:54,130
但最终这个程序都不会做什么有效地事情
266
00:10:54,300 --> 00:10:55,750
因为我没有把答案打印出来
267
00:10:55,930 --> 00:10:57,140
我没有保存那个答案
268
00:10:57,140 --> 00:10:58,970
我没有对那个答案做相应的操作
269
00:10:59,180 --> 00:11:01,020
所以当我运行这个程序
270
00:11:01,790 --> 00:11:03,690
没有什么会发生
271
00:11:03,690 --> 00:11:05,740
我们接着通过键入"gcc math1 c"来编译这个文件
272
00:11:06,150 --> 00:11:08,830
由于时间的原因  我不会总是
273
00:11:08,830 --> 00:11:11,340
去改变这个文件名字  至少现在不会
274
00:11:12,240 --> 00:11:13,810
它编译成功了
275
00:11:14,040 --> 00:11:15,590
产生一个叫做"a out"的程序
276
00:11:15,590 --> 00:11:18,700
我运行它  回车  但那里什么也没出现
277
00:11:18,980 --> 00:11:20,950
让我们来做点更有趣点的
278
00:11:20,950 --> 00:11:23,020
看看这个文件的第二个版本
279
00:11:23,300 --> 00:11:24,570
顺便作为参考
280
00:11:24,570 --> 00:11:27,160
为了避免我们可能忘记一些代码的意思
281
00:11:27,330 --> 00:11:29,730
我通常会用一两个简单的句子
282
00:11:29,730 --> 00:11:31,010
在上面作出注释
283
00:11:31,010 --> 00:11:32,800
那样会提醒我们这个程序是干嘛的
284
00:11:33,030 --> 00:11:34,710
这里有个稍微有趣点的句子
285
00:11:34,710 --> 00:11:37,710
现在在句子中可以看出  这行代码做了什么?
286
00:11:38,690 --> 00:11:39,830
>> 打印答案
287
00:11:40,040 --> 00:11:40,540
>> 大卫:打印答案  对吗?
288
00:11:40,540 --> 00:11:41,970
所以这有少量的修改
289
00:11:41,970 --> 00:11:43,680
我们之前遇到过这个语法
290
00:11:43,870 --> 00:11:45,750
上次我们通常用"printf"
291
00:11:45,750 --> 00:11:49,260
来打印一个静态的字符串  像硬编码的字符串"David"
292
00:11:49,260 --> 00:11:51,030
这只是个例子
293
00:11:51,280 --> 00:11:53,710
但是请记住我们的确介绍过这一个函数
294
00:11:53,880 --> 00:11:58,040
一个你们能使用的功能--像用户询问一些文本信息
295
00:11:58,300 --> 00:12:01,000
把它拿回来  然后把它放到一个可变的格式字符串中  因为
296
00:12:01,000 --> 00:12:03,700
printf是美妙的--这也是这个"f"蕴含的
297
00:12:03,700 --> 00:12:07,260
我可以在双引号中嵌入特殊的字符串
298
00:12:07,260 --> 00:12:11,800
像"%d"是用来打印数字  "%s"用来打印字符串
299
00:12:11,800 --> 00:12:13,650
还有一些其他的符号  我们以后会接触到
300
00:12:13,990 --> 00:12:17,810
这其中还有一个逗号分开的有值的占位符
301
00:12:17,940 --> 00:12:20,550
我把它放到了引号之后
302
00:12:20,550 --> 00:12:22,760
这是一个很有用的方法  如果你之前不是很了解
303
00:12:22,760 --> 00:12:25,080
在句子中要加入什么  但是这个方法可以
304
00:12:25,080 --> 00:12:28,560
动态地创建字符串 短语 句子
305
00:12:28,560 --> 00:12:30,990
那个是有用的  因为我不需要预先知道
306
00:12:30,990 --> 00:12:33,540
那个答案将会变成什么
307
00:12:33,540 --> 00:12:36,100
或者那个字符串将变成什么的时候
308
00:12:36,100 --> 00:12:40,400
所以我强调这点  我可以运行"gcc math2 c"
309
00:12:40,400 --> 00:12:43,830
但是我不是很喜欢a out这个默认的名字
310
00:12:43,830 --> 00:12:45,880
想取消它  那么这里有个叫做"make"的命令
311
00:12:46,140 --> 00:12:48,630
这个命令现在没有很大的改进
312
00:12:48,630 --> 00:12:49,960
只是把用来更改名字用的
313
00:12:50,110 --> 00:12:51,850
等下我们将体会到  当我们要键入的命令是
314
00:12:51,850 --> 00:12:53,890
很长 很复杂的时候
315
00:12:54,050 --> 00:12:56,230
要键入它们就变得比较麻烦 并且也很难记忆
316
00:12:56,230 --> 00:12:58,640
所以make通常使这个过程自动化
317
00:12:58,990 --> 00:13:00,300
唯一的不同在于我只要键入
318
00:13:00,330 --> 00:13:04,140
"math2"而不用键入"make math2 c"
319
00:13:04,310 --> 00:13:08,990
假设我在一个叫做"make math2 c"的文件里
320
00:13:08,990 --> 00:13:10,220
然后去找它
321
00:13:10,430 --> 00:13:12,690
现在请注意这个命令--这里没有错误信息--
322
00:13:12,900 --> 00:13:14,950
make是向我们显示了这些命令
323
00:13:14,950 --> 00:13:16,850
它根据我们的利益而执行的
324
00:13:17,350 --> 00:13:20,040
实际上  一旦我们开始写一些更复杂的程序时
325
00:13:20,290 --> 00:13:25,110
你们可能要键入那样一些长的 讨厌的命令
326
00:13:25,110 --> 00:13:26,970
来编译跟高级的程序
327
00:13:27,270 --> 00:13:29,220
所以我们刚学习了怎样简化
328
00:13:29,220 --> 00:13:30,880
操作的一个方法
329
00:13:31,090 --> 00:13:33,480
事实上  作为一个帮助程序  请注意
330
00:13:33,480 --> 00:13:37,150
它为我自动分类:这个是什么东西?
331
00:13:37,740 --> 00:13:37,940
>> CS50
332
00:13:38,120 --> 00:13:39,590
>> 大卫:是的  这是CS50程序库
333
00:13:39,590 --> 00:13:42,840
所以万一我碰巧使用了CS50程序库
334
00:13:43,120 --> 00:13:45,410
我们用这种方法配置了联网
335
00:13:45,410 --> 00:13:48,030
那样我们就有使用它的权利了
336
00:13:48,120 --> 00:13:48,850
所以那是挺有用的
337
00:13:49,080 --> 00:13:51,310
总是能够让你能够使用数学程序库
338
00:13:51,310 --> 00:13:52,290
那也是有用的
339
00:13:52,290 --> 00:13:53,460
所以你不一定要把它记住
340
00:13:53,460 --> 00:13:54,930
这里还有一些其他的标记
341
00:13:54,930 --> 00:13:56,620
我们不会花很多时间在这些上
342
00:13:57,220 --> 00:13:58,710
但是你们刚才被他们忽悠了
343
00:13:59,010 --> 00:14:03,560
"-ggdb"是用来使能"调试标志"功能
344
00:14:03,560 --> 00:14:05,120
的一个标记
345
00:14:05,120 --> 00:14:06,420
接下来几周我们将看到这个命令
346
00:14:06,780 --> 00:14:09,170
但是  在接下来的一两周内  当你们写程序的时候
347
00:14:09,170 --> 00:14:11,410
或至少在第一次写的时候  通常如果你在调试程序
348
00:14:11,410 --> 00:14:13,110
就像你们可能已经试着调试过Scratch
349
00:14:13,110 --> 00:14:15,800
你们或许是通过查看你们的代码
350
00:14:15,800 --> 00:14:17,330
来推断你们的程序
351
00:14:17,330 --> 00:14:19,670
从头到尾  可能还需要别人的帮忙--
352
00:14:19,970 --> 00:14:22,000
但是你的朋友也将要打印输出
353
00:14:22,470 --> 00:14:25,150
所以不要低估下一两周的重要性
354
00:14:25,300 --> 00:14:27,190
虽然我们只将"printf"语句暂时地植入到
355
00:14:27,190 --> 00:14:30,530
我们的代码中  只是用来打印一些
356
00:14:30,530 --> 00:14:32,680
变量或表达式的值
357
00:14:32,880 --> 00:14:34,290
所以你们提醒一下自己
358
00:14:34,290 --> 00:14:36,190
当你们能够确定你们的代码运行正常的话  你们可以把这个"printf"
359
00:14:36,190 --> 00:14:36,740
语句删除掉
360
00:14:36,980 --> 00:14:40,230
"printf"本身在早期就是有用的调试工具
361
00:14:40,480 --> 00:14:43,330
这意味着在不久后  我们将使用一些更高级的
362
00:14:43,330 --> 00:14:43,870
调试方法
363
00:14:44,190 --> 00:14:49,420
对于个细节 在一段时间内 -std=C99 这个叫做
364
00:14:49,420 --> 00:14:52,370
C的比较突出的编程语言  并且它还在改进
365
00:14:52,370 --> 00:14:54,810
在1999年  他们加入了一些新的功能
366
00:14:54,940 --> 00:14:57,140
使编程变得舒服很多
367
00:14:57,140 --> 00:14:58,410
他们废除了一些令人头疼的东西
368
00:14:58,730 --> 00:15:03,060
所以我们在使用的C语言的C99版本
369
00:15:03,310 --> 00:15:05,640
这对今天来说是没多大用处的
370
00:15:05,640 --> 00:15:08,320
只是告诉我们使用的是那个版本而已
371
00:15:08,400 --> 00:15:11,020
如果你来自一个先前的背景
372
00:15:11,280 --> 00:15:12,790
如果你们没有使用这个版本标志的话  在一个不同的系统中
373
00:15:12,790 --> 00:15:14,620
你的代码可能运行地不太一样
374
00:15:14,940 --> 00:15:18,820
现在教学上用的这些东西  -W   -W   -W
375
00:15:19,260 --> 00:15:25,420
这些本质上说明GCC是很挑剔的
376
00:15:25,420 --> 00:15:28,790
这说明为什么GCC尽可能地经常地提醒你
377
00:15:28,830 --> 00:15:31,360
即使是一些最小的事情  来要求你能够
378
00:15:31,360 --> 00:15:34,060
编写出最好的 最稳定的
379
00:15:34,060 --> 00:15:35,830
最正确的代码
380
00:15:35,830 --> 00:15:37,710
所以如果你省略了想这样的标志
381
00:15:37,710 --> 00:15:39,180
有时你的代码能编译通过
382
00:15:39,420 --> 00:15:41,190
但是当你在实际中用make或
383
00:15:41,190 --> 00:15:43,200
所谓的标志来编译它  你会被告知存在
384
00:15:43,200 --> 00:15:45,180
大批的错误  即使你认为你的代码
385
00:15:45,180 --> 00:15:46,810
是非常正确的
386
00:15:46,810 --> 00:15:48,560
我们以后也会演示这些例子
387
00:15:48,560 --> 00:15:51,610
但是现在的任务只是运行我刚写的math2
388
00:15:51,610 --> 00:15:53,380
我得到了答案3  但是它可能
389
00:15:53,380 --> 00:15:54,960
误解了我的意图
390
00:15:55,590 --> 00:16:01,670
为什么这个"3"显示在我的Malan用户名前面
391
00:16:01,670 --> 00:16:02,470
>> 【无法辨认的声音】
392
00:16:02,470 --> 00:16:05,000
>> 大卫:是的  我没有加入"反斜杠 n"
393
00:16:05,000 --> 00:16:07,800
所以如果我打开这个文件  请注意我这里有"%d"
394
00:16:07,800 --> 00:16:09,100
但没有"反斜杠n"--
395
00:16:09,100 --> 00:16:11,400
反斜杠n是用来使光标移到下一行的
396
00:16:11,400 --> 00:16:13,210
就是这样 只是一些很小的细节
397
00:16:13,420 --> 00:16:15,940
好的  让我们开始学习一个稍微
398
00:16:16,540 --> 00:16:17,590
更有趣点的程序
399
00:16:17,590 --> 00:16:19,190
让我们进入这个程序的第三版
400
00:16:19,670 --> 00:16:21,580
开始用这些概念来写点东西
401
00:16:21,580 --> 00:16:24,900
现在实际上我在做一些算术  但是我们
402
00:16:24,900 --> 00:16:26,190
将会被一些细微的差别所阻塞
403
00:16:26,190 --> 00:16:27,870
这个程序跟习题集1中的
404
00:16:27,870 --> 00:16:32,630
一部分比较相似  至少在习题1中
405
00:16:32,910 --> 00:16:34,220
这里我在做什么?
406
00:16:34,380 --> 00:16:36,810
哦!--下次我把这个字体颜色改成蓝色的--
407
00:16:36,810 --> 00:16:38,980
我先告诉编译器--我需要使用
408
00:16:39,040 --> 00:16:40,540
标准输入输出库
409
00:16:40,620 --> 00:16:42,400
因为printf在那个库里面申明的
410
00:16:42,850 --> 00:16:45,030
我指明"这里是我的主函数
411
00:16:45,030 --> 00:16:46,480
这里是我的程序内容 "
412
00:16:46,760 --> 00:16:48,710
然后这里  这只是一个子程序
413
00:16:48,950 --> 00:16:52,690
在那里面我硬编码了表达式"17除以13"
414
00:16:52,980 --> 00:16:55,540
我把这个答案存储在一个float类型的
415
00:16:55,590 --> 00:16:57,230
叫做"answer"的变量中
416
00:16:57,630 --> 00:16:59,680
由于  float就是一个浮点数值
417
00:16:59,680 --> 00:17:01,640
所以  不同于int  这个类型的数字
418
00:17:01,640 --> 00:17:03,340
可以有小数位
419
00:17:03,340 --> 00:17:04,840
这样才有意义  因为这个结果将不会是
420
00:17:04,840 --> 00:17:06,050
一个整数  对吗?
421
00:17:06,050 --> 00:17:10,930
17除以3(13)大概是多少呢--1点几
422
00:17:11,060 --> 00:17:12,540
所以是1点几 几 几  是不?
423
00:17:12,600 --> 00:17:14,740
所以这个到底有什么作用呢?
424
00:17:14,740 --> 00:17:15,860
为什么这个值得大家关注呢?
425
00:17:15,860 --> 00:17:16,670
嗯  我们先编译它
426
00:17:16,820 --> 00:17:21,530
这是math3  所以键入"make math3"  回车
427
00:17:21,860 --> 00:17:24,510
现在我将运行math3
428
00:17:25,040 --> 00:17:28,920
我的程序或这台电脑是不是坏了?
429
00:17:29,300 --> 00:17:31,820
它觉得这个答案是1 00
430
00:17:32,530 --> 00:17:33,420
为什么呢?
431
00:17:33,580 --> 00:17:37,860
这是那个源代码
432
00:17:37,860 --> 00:17:38,870
>> 【无法辨认的声音】
433
00:17:38,870 --> 00:17:38,940
>> 大卫:是的
434
00:17:38,940 --> 00:17:40,680
所以那只是好的直觉
435
00:17:40,680 --> 00:17:43,120
我们上次看到  这里是剩下的操作
436
00:17:43,120 --> 00:17:45,820
我的确希望有一个方法来修正这个错误  但是看起来
437
00:17:45,820 --> 00:17:49,950
好像那个除法操作  那个斜杠是除法
438
00:17:50,230 --> 00:17:52,040
但是--对于很多编程语言来说
439
00:17:52,040 --> 00:17:56,060
是挺奇怪的--因为17是一个整数
440
00:17:56,060 --> 00:17:58,710
13也是一个整数  为什么我这样说?
441
00:17:58,750 --> 00:18:00,580
这里没有小数点 这里没有 0
442
00:18:00,580 --> 00:18:03,350
这里没有浮点数值  它只是一个整型数字
443
00:18:03,770 --> 00:18:07,180
当你把一个整型数除以一个整型数时
444
00:18:07,520 --> 00:18:10,050
无论如何答案将会是一个整型数
445
00:18:10,050 --> 00:18:12,910
所以即使那个正确的答案是1 4
446
00:18:12,910 --> 00:18:16,660
或别的数值  当你用一个整型数除以一个整型数
447
00:18:16,940 --> 00:18:19,850
在那个变量的返回值里  只有
448
00:18:19,920 --> 00:18:21,220
存储一个整型数的空间
449
00:18:21,220 --> 00:18:21,910
所以发生了什么呢?
450
00:18:22,220 --> 00:18:24,970
所有小数点后面的数值都被砍掉了
451
00:18:24,970 --> 00:18:26,110
它不会四舍五入
452
00:18:26,250 --> 00:18:27,240
可能直接舍掉了
453
00:18:27,240 --> 00:18:29,030
但是它不会像你想象的那样恰当地四舍五入的
454
00:18:29,250 --> 00:18:32,680
它直接把小数点后面的数值丢弃掉了  因为
455
00:18:32,870 --> 00:18:36,090
凭直觉  那些整型数和结果应该是一个浮点数据
456
00:18:36,090 --> 00:18:38,130
但是我需要一个更精确的数值
457
00:18:38,480 --> 00:18:41,080
说点题外话  结果你可以用printf来打印其他的格式
458
00:18:41,180 --> 00:18:43,340
这是非常有用的
459
00:18:43,340 --> 00:18:44,630
甚至是为了ASCII艺术的目的
460
00:18:45,030 --> 00:18:46,160
这次我不只是讲"%f"
461
00:18:46,160 --> 00:18:54,060
我要讲的是 % --什么呢--% 2f
462
00:18:54,620 --> 00:18:55,590
这个是什么意思呢?
463
00:18:55,690 --> 00:18:57,020
嗯  你们可以推断一下
464
00:18:57,020 --> 00:18:59,050
如果刚才我回到那段代码中去
465
00:18:59,050 --> 00:19:05,240
我们回到math3  请注意在小数点后面
466
00:19:05,240 --> 00:19:06,550
会打印几位数呢--两位?
467
00:19:06,850 --> 00:19:10,800
所以我们用printf也可以控制这种
468
00:19:10,800 --> 00:19:12,400
打印结果的美观性
469
00:19:12,400 --> 00:19:14,070
在习题集中如果你们遇到相关的问题
470
00:19:14,260 --> 00:19:16,560
我们会提供适当的文档资料
471
00:19:16,790 --> 00:19:17,510
让我们来修正这个程序
472
00:19:17,550 --> 00:19:18,560
这个第三个版本的
473
00:19:18,770 --> 00:19:20,410
让我们继续来修正这个问题
474
00:19:20,560 --> 00:19:21,450
好的  直观地看
475
00:19:21,450 --> 00:19:23,620
如果那个问题的原因是因为整型数除以整型数的话
476
00:19:23,710 --> 00:19:27,260
无疑有个解决方案是:"不要那样做"  是吗?
477
00:19:27,260 --> 00:19:30,140
我们用一个整型数除以浮点数
478
00:19:30,370 --> 00:19:32,310
所以我可以通过改变其中一个
479
00:19:32,310 --> 00:19:34,310
整型数为浮点数
480
00:19:34,440 --> 00:19:38,240
说点题外话  我承认这是一个完全无用的程序
481
00:19:38,240 --> 00:19:39,930
跟我们之前写的两个程序一样
482
00:19:39,930 --> 00:19:41,940
我们为什么需要写个程序来解决这个数学运算呢?
483
00:19:41,940 --> 00:19:43,310
我们可以用一个计算器或
484
00:19:43,310 --> 00:19:44,840
其他的运算工具来计算那个结果
485
00:19:45,040 --> 00:19:50,020
但是这里我在做一个同样的计算
486
00:19:50,020 --> 00:19:52,590
除了在下面的分母是13 0
487
00:19:52,590 --> 00:19:56,230
所以现在我键入"make math4"来编译第四个版本
488
00:19:56,230 --> 00:20:00,600
然后运行math4  我得到了1 31
489
00:20:00,600 --> 00:20:02,870
这里可能有更多的小数位
490
00:20:02,870 --> 00:20:04,500
但因为我对结果设定了格式
491
00:20:04,860 --> 00:20:05,910
我们只看到两位
492
00:20:05,910 --> 00:20:07,770
这个可能有用  当你想把它的格式
493
00:20:07,770 --> 00:20:09,640
变得美观一点的时候
494
00:20:10,010 --> 00:20:12,880
让我们再来看看第五个也是最后一个版本
495
00:20:13,060 --> 00:20:15,730
结果在包括C语言的很多语言当中
496
00:20:15,940 --> 00:20:19,060
你作为一个程序员懂得了一些计算机的工作方式
497
00:20:19,060 --> 00:20:19,870
和语言的处理方式
498
00:20:20,060 --> 00:20:22,160
可以更精确地控制运用它
499
00:20:22,160 --> 00:20:23,790
你不需要这样来操作  比如
500
00:20:23,790 --> 00:20:26,390
手动地加入小数点来修正这个错误
501
00:20:26,630 --> 00:20:30,290
你可以控制编译器处理
502
00:20:30,540 --> 00:20:32,060
不同类型的数据
503
00:20:32,060 --> 00:20:33,780
至少我们凭直觉
504
00:20:33,970 --> 00:20:35,130
它应该是可能的
505
00:20:35,440 --> 00:20:39,550
所以这里我要做的是用17除以13
506
00:20:39,550 --> 00:20:43,510
但因为这样的题外话  (浮点数)
507
00:20:43,510 --> 00:20:45,600
因为那样的题外话--
508
00:20:45,600 --> 00:20:46,620
还是没有做完这个数学题
509
00:20:46,790 --> 00:20:48,170
这是一个编程语言的东西--
510
00:20:48,500 --> 00:20:50,890
那是一个计算操作
511
00:20:52,230 --> 00:20:55,100
所以这里的意思是编译器将
512
00:20:55,100 --> 00:20:58,800
做"计算"  譬如13这样一个浮点数
513
00:20:58,800 --> 00:21:00,950
--到另一个浮点数--
514
00:21:01,260 --> 00:21:03,040
然后为我们处理除法
515
00:21:03,040 --> 00:21:06,150
以便严格地修正这个问题
516
00:21:06,340 --> 00:21:07,520
为什么这是有用的呢?
517
00:21:07,520 --> 00:21:09,530
好  我们等下讲讲密码学
518
00:21:09,530 --> 00:21:12,080
密码包含不规则的信息
519
00:21:12,080 --> 00:21:15,550
它把我们正常人能读懂的东西转化为
520
00:21:15,550 --> 00:21:17,770
希望坏人读不懂的东西
521
00:21:17,950 --> 00:21:19,640
但是自从上周我们已经知道
522
00:21:19,770 --> 00:21:21,730
计算机最终是用数字来表示所有的
523
00:21:21,730 --> 00:21:23,030
信息  如果它们要描绘
524
00:21:23,030 --> 00:21:25,520
在内存中的字母
525
00:21:25,870 --> 00:21:27,410
它们该怎么做  用什么方式呢?
526
00:21:28,830 --> 00:21:31,170
它们想描绘字母而不只是数字
527
00:21:31,630 --> 00:21:33,630
>> 【无法辨认的声音】
528
00:21:34,090 --> 00:21:35,970
>> 大卫:是这样的  不是二进制本身  而是用ASCII码  对吗?
529
00:21:35,970 --> 00:21:38,970
你只需要提出一个使之与数字对应的协定
530
00:21:38,970 --> 00:21:41,170
那样计算机就可以方便地存储它们
531
00:21:41,410 --> 00:21:42,540
你必须提出一个
532
00:21:42,540 --> 00:21:43,780
数字与字母对应的协定
533
00:21:43,780 --> 00:21:46,140
我们目前看到的这个东西叫做"ASCII"码
534
00:21:46,440 --> 00:21:49,320
现在ASCII码包含字符了
535
00:21:49,320 --> 00:21:51,210
我们知道从周三起--简单说下--
536
00:21:51,210 --> 00:21:53,980
我们有个叫做"char"或"char"(读法不同)
537
00:21:53,980 --> 00:21:56,640
看你们怎么读它了  那代表一个单一的字符
538
00:21:56,990 --> 00:21:58,170
但那里会有个整型数与之对应
539
00:21:58,640 --> 00:22:02,460
如果我们知道65是个整型数  对应的是
540
00:22:02,620 --> 00:22:05,580
大写字母"A"  我们已经口头地说明
541
00:22:05,580 --> 00:22:09,250
我们可以把数字转换为字符  字符转化为数字
542
00:22:09,400 --> 00:22:12,050
所以这里就是我们将要学习的一种语法
543
00:22:12,050 --> 00:22:14,810
如果你要把一个像65这样的数字转换为字母A
544
00:22:15,080 --> 00:22:18,920
你只需要告诉计算机"把那个int型数据转换成char型处理"
545
00:22:18,920 --> 00:22:21,350
如果你想做相反的转换  你就告诉计算机
546
00:22:21,560 --> 00:22:23,240
"把那个char型数据转换成int型处理"
547
00:22:23,240 --> 00:22:25,880
所以这是一个函数引导
548
00:22:26,180 --> 00:22:27,920
现在为了这些数据量
549
00:22:27,920 --> 00:22:30,290
让我们先结束一个未解决的问题
550
00:22:30,550 --> 00:22:32,260
这里有个小程序  其中里面有个
551
00:22:32,490 --> 00:22:34,620
备忘单对我是有点用的
552
00:22:34,930 --> 00:22:38,350
我声明了四个变量:"c"是char型的
553
00:22:38,350 --> 00:22:40,340
"d"是double型的  "f"是float型的
554
00:22:40,340 --> 00:22:41,330
"i"是int型的
555
00:22:41,380 --> 00:22:43,730
这是我们到现在为止学习了的四个数据类型
556
00:22:44,050 --> 00:22:46,650
我不太记得类中的这些类型
557
00:22:46,650 --> 00:22:49,120
是多大的  嗯
558
00:22:49,120 --> 00:22:51,070
结果是--这个在以后比现在
559
00:22:51,070 --> 00:22:55,330
可能是更有用的--不过C语言中有个sizeof的操作符
560
00:22:55,670 --> 00:22:57,350
其中括号里有一个参数
561
00:22:57,350 --> 00:23:00,540
它会告诉我们  要存储一个类型的数据
562
00:23:00,540 --> 00:23:01,760
需要占用多大空间
563
00:23:02,070 --> 00:23:05,250
所以我将要逐行地打印出一个char类型占了几个字节
564
00:23:05,250 --> 00:23:08,330
一个double类型要占了几个字节  还有float和int类型
565
00:23:08,680 --> 00:23:09,990
所以这大部分都是复制粘贴
566
00:23:09,990 --> 00:23:11,860
其中唯一的区别是数据类型的名字
567
00:23:11,860 --> 00:23:13,880
和我使用的变量名字
568
00:23:14,130 --> 00:23:15,720
让我们继续编译"make sizeof"
569
00:23:15,720 --> 00:23:18,160
接着运行"run sizeof"
570
00:23:18,450 --> 00:23:19,540
我们要确认一些几天前
571
00:23:19,540 --> 00:23:21,450
我们讲过的一些东西
572
00:23:21,920 --> 00:23:25,400
所以char类型占了1个字节  --那是多少位?
573
00:23:25,640 --> 00:23:25,970
>> 8位
574
00:23:26,040 --> 00:23:26,750
>> 大卫:是8位
575
00:23:26,750 --> 00:23:27,870
现在那是相当容易了
576
00:23:28,150 --> 00:23:31,590
float类型和int类型都占四个字节
577
00:23:31,590 --> 00:23:33,630
那一个int型的呢
578
00:23:33,630 --> 00:23:36,960
由于它占4个字节  那是32位
579
00:23:36,960 --> 00:23:39,470
所以它可以表示的最大的数值是多少呢
580
00:23:39,470 --> 00:23:41,180
大概是多少?用32位表示?
581
00:23:41,250 --> 00:23:41,840
>> 40亿
582
00:23:42,230 --> 00:23:43,160
>> 大卫:是40亿
583
00:23:43,160 --> 00:23:45,180
如果你想也用来表示负数呢?
584
00:23:45,180 --> 00:23:46,590
你不得不拿出一部分来表示
585
00:23:46,590 --> 00:23:49,170
所以大概是负20亿到正20亿
586
00:23:49,460 --> 00:23:51,110
这是相关的
587
00:23:51,110 --> 00:23:53,570
所以20亿  40亿--这都是很大的数值
588
00:23:53,800 --> 00:23:56,470
但是世界上有很多"数十亿的东西"  对不?
589
00:23:56,470 --> 00:23:57,700
有数十亿的原子
590
00:23:57,700 --> 00:24:00,120
现在网页可能都有数十亿
591
00:24:00,350 --> 00:24:03,460
如果一台计算机只能够支持20亿
592
00:24:03,460 --> 00:24:06,220
或者40亿  那我们该怎么办?
593
00:24:06,220 --> 00:24:08,450
这确实是个问题
594
00:24:08,450 --> 00:24:10,980
这个跟10年前发生的事情有点不一样
595
00:24:10,980 --> 00:24:13,680
那个所谓的"Y2K"问题
596
00:24:13,680 --> 00:24:14,680
本质上的结果是
597
00:24:14,680 --> 00:24:17,190
程序员没有真实地预见和认识到
598
00:24:17,450 --> 00:24:20,260
"可能我们没必要用到这些位数或数字
599
00:24:20,260 --> 00:24:22,930
来表示一年  但是最终这个将会
600
00:24:22,930 --> 00:24:23,460
是个问题
601
00:24:23,680 --> 00:24:26,260
公平起见  那个问题有时会发生
602
00:24:26,510 --> 00:24:29,480
因为实际上  很多企业在这么多年里运行了
603
00:24:29,610 --> 00:24:32,590
比程序员多得多的代码
604
00:24:32,590 --> 00:24:35,050
虽然他们将运行它  但那个构想还是一样的
605
00:24:35,350 --> 00:24:37,540
所以这里有一个解决方案:
606
00:24:37,810 --> 00:24:42,110
如果你需要比float类型允许的更高精度  小数点后更多位数
607
00:24:42,110 --> 00:24:44,560
那你该用什么取代它?
608
00:24:44,560 --> 00:24:44,970
>> double类型
609
00:24:45,280 --> 00:24:45,830
>> 大卫:double类型
610
00:24:45,830 --> 00:24:47,240
double类型占64位
611
00:24:47,500 --> 00:24:49,160
现在这个可以表示的数值是相当大的了
612
00:24:49,160 --> 00:24:52,270
这是2的64次方  是相当大的数字了
613
00:24:52,480 --> 00:24:55,630
但在当今的社会上  我们将讨论一点安全方面的知识
614
00:24:55,630 --> 00:24:58,470
贯穿整个课程  密码学--
615
00:24:58,510 --> 00:25:00,690
加密一些像信用卡信息
616
00:25:00,690 --> 00:25:02,890
银行账号之类的东西--你不能用32位
617
00:25:03,410 --> 00:25:04,790
你也不能用64位
618
00:25:05,030 --> 00:25:09,230
你通常要使用1024位  4048位
619
00:25:09,410 --> 00:25:10,790
我的意思是它们是非常 非常巨大的
620
00:25:10,790 --> 00:25:13,870
数字  用来为保护我们的数据
621
00:25:13,870 --> 00:25:18,900
但是它终归是各种各样的存储的基本要素
622
00:25:18,900 --> 00:25:19,970
【电话响了】
623
00:25:19,970 --> 00:25:21,210
对不起  我接个电话
624
00:25:21,590 --> 00:25:24,430
没响了
625
00:25:25,810 --> 00:25:26,690
好的
626
00:25:26,690 --> 00:25:27,480
有什么问题吗?
627
00:25:27,480 --> 00:25:30,810
一些比较无趣的数字 一些关于类型的大小
628
00:25:30,810 --> 00:25:32,860
在我们现在进行试验之前
629
00:25:32,860 --> 00:25:36,790
你们对这其中的语法或概念有什么问题吗?
630
00:25:36,960 --> 00:25:37,080
请说?
631
00:25:37,820 --> 00:25:42,970
>> 有没有能表示1024位大小的数据类型或--
632
00:25:43,040 --> 00:25:43,470
>> 大卫:好问题
633
00:25:43,470 --> 00:25:44,470
有这样一个数据类型吗?
634
00:25:44,470 --> 00:25:46,650
有一个像int char double这样的关键字
635
00:25:46,650 --> 00:25:50,050
用来表示一个1024位大小的数值呢?
636
00:25:50,420 --> 00:25:53,210
简单回答:没有  至少在C语言里是没有的 你可以
637
00:25:53,210 --> 00:25:56,220
在C语言或其他语言中创建这样一个结构体
638
00:25:56,500 --> 00:25:57,310
但是立即可以用的
639
00:25:57,310 --> 00:25:59,290
我们通常只有这些所谓的"基本数据类型"
640
00:25:59,400 --> 00:26:02,100
事实上  int数据类型还是没什么用--40亿--
641
00:26:02,100 --> 00:26:03,610
我们还是没有解决那个问题
642
00:26:03,850 --> 00:26:08,810
所以我们能用什么数据类型来表示
643
00:26:08,810 --> 00:26:09,650
比int类型更多位数的数呢
644
00:26:09,750 --> 00:26:10,590
谁知道叫做什么吗?
645
00:26:10,590 --> 00:26:15,450
你们有可能看到过long  那个在一些服务器上是正确的
646
00:26:15,450 --> 00:26:18,730
但是非常 非常普遍的是  那个叫做"long"的数据类型
647
00:26:18,730 --> 00:26:21,240
只占有4个字节
648
00:26:21,650 --> 00:26:24,180
所以事实上  如果你需要一个超级长的数字--
649
00:26:24,180 --> 00:26:25,810
让我们继续重新讨论这个问题--
650
00:26:26,120 --> 00:26:27,350
你可以声明long
651
00:26:27,490 --> 00:26:29,260
让我们来试一下  long l
652
00:26:29,260 --> 00:26:31,320
然后我在这里复制粘贴一下
653
00:26:31,320 --> 00:26:36,410
这里long的大小实际上是l的大小 所以让我退出
654
00:26:36,410 --> 00:26:38,170
那个程序 重新编译
655
00:26:38,170 --> 00:26:40,560
这里有个小技巧--此外  我们许诺指出行业中的
656
00:26:40,560 --> 00:26:41,670
一些小技巧--
657
00:26:41,900 --> 00:26:44,280
如果我知道我想执行我写入的上一个命令
658
00:26:44,280 --> 00:26:48,000
是以m开头的  !m会明白那个命令是什么
659
00:26:48,000 --> 00:26:50,150
然后为我恢复上次操作
660
00:26:50,150 --> 00:26:52,000
所以我不需要明白它  或者你可以回到
661
00:26:52,000 --> 00:26:53,680
那个终端窗口
662
00:26:53,940 --> 00:26:55,430
所以现在我在敲右箭头(↑)键
663
00:26:55,640 --> 00:26:56,860
先在我敲下箭头(↓)键
664
00:26:56,860 --> 00:26:58,400
所以我们可以滚回到我们(敲过的命令)的历史记录
665
00:26:58,400 --> 00:27:00,200
这个可以节约我们的时间
666
00:27:00,480 --> 00:27:03,150
我们继续然后返回sizeof  敲Enter键
667
00:27:03,150 --> 00:27:04,830
这个是相当没用的  对不?
668
00:27:04,830 --> 00:27:08,530
long类型  至少在这个Linux系统的主机上
669
00:27:08,660 --> 00:27:10,010
他们是相同的大小
670
00:27:10,070 --> 00:27:14,570
所以结果是  那个时候无论是谁想出的这个  要么是可笑的
671
00:27:14,570 --> 00:27:15,870
要么是没创造性的
672
00:27:16,040 --> 00:27:17,960
如果你们真的需要一个很长的数值
673
00:27:18,360 --> 00:27:19,840
有一个叫做"long long"的类型
674
00:27:20,110 --> 00:27:21,190
要么叫做ll
675
00:27:21,260 --> 00:27:23,560
让我再做个复制粘贴
676
00:27:23,560 --> 00:27:25,040
所以我能打印它的大小
677
00:27:25,430 --> 00:27:27,420
如果我重新编译--
678
00:27:27,480 --> 00:27:30,750
别介意我操作地非常快
679
00:27:30,750 --> 00:27:32,130
我在做和之前一样的事情--
680
00:27:32,130 --> 00:27:34,220
敲Enter键  现在我们有8个字节
681
00:27:34,390 --> 00:27:36,380
所以8(字节)是个相当巨大的数字了
682
00:27:36,380 --> 00:27:37,800
这个也蛮有用的
683
00:27:37,800 --> 00:27:38,800
到这个学期的期末
684
00:27:38,950 --> 00:27:40,550
我们会讨论数据库的设计
685
00:27:40,550 --> 00:27:43,440
你们其中的一两个习题集会用到一个
686
00:27:43,440 --> 00:27:45,820
叫做MySQL的数据库  那个是非常流行的数据库--
687
00:27:45,850 --> 00:27:47,800
Facebook使用了它  各种各样的公司也使用它
688
00:27:47,940 --> 00:27:49,600
当你开始存储很多很多的数据的时候
689
00:27:49,770 --> 00:27:52,950
你的确需要这个管理很多数据的功能
690
00:27:53,180 --> 00:27:56,000
幸亏有64位的数值  我们才能做到如此
691
00:27:56,160 --> 00:27:58,270
但是我们的空间真的会用完
692
00:27:58,300 --> 00:27:59,670
即使有这样的数据类型
693
00:27:59,670 --> 00:28:02,620
所以我希望我们不要两次犯同一个错误
694
00:28:03,030 --> 00:28:05,400
好的  这里有一个可能常见的
695
00:28:05,490 --> 00:28:07,380
但可能未留下深刻印象的公式
696
00:28:07,380 --> 00:28:08,620
这个东西描绘的是什么呢?
697
00:28:09,200 --> 00:28:10,970
>> 怎样从华氏温度获得摄氏温度
698
00:28:11,040 --> 00:28:11,150
>> 大卫:是的
699
00:28:11,150 --> 00:28:13,090
所以这个是怎么从华氏温度获得摄氏温度
700
00:28:13,090 --> 00:28:15,490
如果你知道一个华氏温度的温度值
701
00:28:15,720 --> 00:28:17,040
你们输出摄氏温度
702
00:28:17,550 --> 00:28:19,910
这就有几分像经典的计算机科学
703
00:28:19,910 --> 00:28:21,370
101-类型问题
704
00:28:21,800 --> 00:28:24,050
这是美好的  虽然  只有在那个里面它才会给我们一个机会
705
00:28:24,050 --> 00:28:24,890
来填充那个空白表格
706
00:28:24,890 --> 00:28:25,750
所以这里是一个空白表格
707
00:28:25,960 --> 00:28:28,150
如果你有一张废弃的纸张
708
00:28:28,460 --> 00:28:31,320
假如你已经开始了以下的问题
709
00:28:31,570 --> 00:28:32,980
请注意我做了一个改变
710
00:28:32,980 --> 00:28:35,690
在周三我在那个网站上尽可能地
711
00:28:35,880 --> 00:28:38,270
简化代码的时候  我有点偷懒
712
00:28:38,510 --> 00:28:40,400
但结果是我们将看到
713
00:28:40,630 --> 00:28:42,960
函数绝对是有参数的  对不对?
714
00:28:42,960 --> 00:28:45,920
printf的括号里是有参数的
715
00:28:46,190 --> 00:28:49,210
但是  main函数  至少现在是没有参数的
716
00:28:49,330 --> 00:28:52,180
所以在周三  我只加入了左括号  右括号
717
00:28:52,580 --> 00:28:55,300
但是这的确是正确的方法来指明
718
00:28:55,300 --> 00:28:57,170
这个函数是没有参数
719
00:28:57,350 --> 00:28:59,660
实际上是写了这个关键字"void"
720
00:28:59,660 --> 00:29:01,290
所以我现在将开始养成那个习惯
721
00:29:01,290 --> 00:29:02,970
虽然这是一个有点分散注意力的细节
722
00:29:03,200 --> 00:29:06,330
它只是与编译器
723
00:29:06,330 --> 00:29:07,630
拥有的期望是并存的
724
00:29:07,970 --> 00:29:10,470
让我用这个来挑战你们:
725
00:29:10,470 --> 00:29:13,550
在这些花括号里面  我通过双斜杠写入了一个注释
726
00:29:13,730 --> 00:29:16,250
--一条"注释"在这里不会被编译
727
00:29:16,250 --> 00:29:18,180
它只是用来我们阅读的
728
00:29:18,380 --> 00:29:20,640
程序员通常写TODO不使用空格
729
00:29:20,640 --> 00:29:23,210
像这样的大写意思是"这里我需要做些事情"
730
00:29:23,560 --> 00:29:27,600
继续和你旁边的人执行程序
731
00:29:27,780 --> 00:29:32,340
取来自用户的整数F作为输入
732
00:29:32,340 --> 00:29:37,080
然后打印出与之等价的摄氏温度的答案
733
00:29:37,160 --> 00:29:40,440
所以输入是一个int类型的F  在你的屏幕上
734
00:29:40,440 --> 00:29:42,060
或你们的纸上打印出C的数值
735
00:29:42,060 --> 00:29:45,390
可能你们需要两行或者三行的代码
736
00:29:45,390 --> 00:29:47,900
但是最终的目标需要你自己独自尝试
737
00:29:48,100 --> 00:29:50,620
和你身边的人比较30到60秒钟
738
00:29:50,800 --> 00:29:54,010
看看是否在我揭露答案之前  我们不能使每个人
739
00:29:54,170 --> 00:29:55,520
得到一个完全相同的页面
740
00:29:56,510 --> 00:30:26,020
【音乐】
741
00:30:26,520 --> 00:30:27,550
>> 大卫:我们再放一次音乐
742
00:30:29,510 --> 00:30:58,550
【音乐】
743
00:30:59,050 --> 00:31:00,850
>> 大卫:叫做什么?
744
00:31:00,850 --> 00:31:01,200
>> 【听不见的声音】
745
00:31:01,200 --> 00:31:01,360
>> 大卫:好的
746
00:31:01,660 --> 00:31:03,600
如果你还没有做好  那就看看你旁边的人
747
00:31:03,600 --> 00:31:06,740
如果你不认识他们就跟他们打个招呼
748
00:31:07,020 --> 00:31:10,680
让我们看看你们
749
00:31:10,680 --> 00:31:11,880
解决了多少迷惑
750
00:31:11,880 --> 00:31:13,850
这里嵌入了两三个提示
751
00:31:14,070 --> 00:31:15,760
有的同学可能想知道:
752
00:31:15,760 --> 00:31:17,500
"我们怎么通过用户获得那个int数值"
753
00:31:17,620 --> 00:31:21,450
好的  请记住从周三开始我们介绍了CS50的函数库
754
00:31:21,450 --> 00:31:23,900
我们刚开始使用了它  里面有很多的
755
00:31:23,900 --> 00:31:27,600
有用的函数  像GetInt  GetString   GetDouble
756
00:31:27,970 --> 00:31:30,060
GetFloat   GetLongLong
757
00:31:30,220 --> 00:31:32,860
所以  那些名字暗示  你可以挑选这些
758
00:31:32,860 --> 00:31:34,680
没有参数的函数  然后你可以通过它的名字
759
00:31:35,060 --> 00:31:36,920
获取他们的数据类型
760
00:31:37,220 --> 00:31:40,240
所以我可以--这里的提示看起来好像
761
00:31:40,240 --> 00:31:42,390
你可能的确想使用CS50的函数库
762
00:31:42,530 --> 00:31:45,530
因为我包含了所谓的头文件
763
00:31:45,530 --> 00:31:47,910
Stdio h  同时  我事先包含它  这是为什么?
764
00:31:47,910 --> 00:31:49,250
>> 【听不见的】
765
00:31:49,250 --> 00:31:51,660
>> 大卫:所以你需要这个库来使用printf  对不对
766
00:31:51,660 --> 00:31:53,210
如果你的确想打印出那个值
767
00:31:53,210 --> 00:31:54,290
而不是把它丢弃掉
768
00:31:54,550 --> 00:31:56,360
所以这是个可以插入字符的括号
769
00:31:56,360 --> 00:31:59,080
让我继续在括号里加上void
770
00:31:59,080 --> 00:32:01,560
但是我们将在下周精确地解释为什么
771
00:32:01,560 --> 00:32:02,850
什么时候我们那样做
772
00:32:03,150 --> 00:32:05,070
你们怎么认为?
773
00:32:06,030 --> 00:32:07,240
在这个末端  printf函数?
774
00:32:07,810 --> 00:32:09,330
所以你们可能选择了一个不同的语句
775
00:32:09,330 --> 00:32:10,400
或其它的东西  但是那挺好的
776
00:32:10,400 --> 00:32:12,850
华氏温度可能用一个间隔来
777
00:32:12,850 --> 00:32:14,960
使其更加美观和有趣
778
00:32:15,320 --> 00:32:18,350
然后你声明一个float类型f  再赋值--
779
00:32:18,400 --> 00:32:20,290
让我向上为你们回滚到--
780
00:32:20,890 --> 00:32:23,810
给出了GetFloat的返回值
781
00:32:24,320 --> 00:32:25,060
对还是不对?
782
00:32:25,330 --> 00:32:27,860
至少大部分人有一些东西沿着那些代码行
783
00:32:27,930 --> 00:32:29,710
没事的 好的 那不是个问题
784
00:32:29,900 --> 00:32:32,010
实际上这个是在干吗?
785
00:32:32,010 --> 00:32:33,910
好的  记住那个GetFloat是一个函数
786
00:32:34,180 --> 00:32:37,310
它被定义在CS50的函数库中 它的唯一目的是
787
00:32:37,350 --> 00:32:41,150
向用户询问一个浮点数的值  然后返回它
788
00:32:41,590 --> 00:32:44,760
那个放在变量中的值是取决于我所赋的值
789
00:32:45,030 --> 00:32:46,730
把它想象成一个黑盒子
790
00:32:46,940 --> 00:32:48,230
我说:"给我一个浮点数"
791
00:32:48,230 --> 00:32:49,170
它就给我一个浮点数
792
00:32:49,290 --> 00:32:51,440
我现在需要把这个浮点数放在哪个地方  然后我把它放在
793
00:32:51,440 --> 00:32:53,050
一个叫做f的变量里
794
00:32:53,120 --> 00:32:54,170
你也可以给这个变量取其它的你喜欢的名字
795
00:32:54,400 --> 00:32:55,750
现在我需要做一个数学运算
796
00:32:56,350 --> 00:32:59,280
这里我声明了一个变量C
797
00:32:59,390 --> 00:33:01,570
然后我把那个幻灯片上的公式
798
00:33:01,570 --> 00:33:04,490
用键盘上的字符翻译成了
799
00:33:04,770 --> 00:33:06,930
浮点数值
800
00:33:07,210 --> 00:33:08,980
但是这里有一个可能性--
801
00:33:08,980 --> 00:33:10,720
这就是你需要把
802
00:33:10,720 --> 00:33:12,710
一些线索拼凑在一起--
803
00:33:12,940 --> 00:33:15,520
我这里所做的是很有趣的  如果我不这样做
804
00:33:15,690 --> 00:33:18,240
我可能已经犯了个数学错误
805
00:33:18,240 --> 00:33:19,150
>> 【无法辨认的声音】
806
00:33:19,150 --> 00:33:21,550
>> 大卫:让我们仔细检查一下这里
807
00:33:21,550 --> 00:33:25,430
我认为这里所有人都好像知道了--是吗?
808
00:33:26,050 --> 00:33:28,830
>> 你把它改为99 0(9 0)
809
00:33:29,040 --> 00:33:30,930
>> 大卫:是的  我故意地把9改成9 0
810
00:33:30,930 --> 00:33:34,470
那样我的数学实际上就是浮点数的了
811
00:33:34,600 --> 00:33:37,190
包括实数  不只是整数
812
00:33:37,190 --> 00:33:41,060
如果我使它保持是9  我可能得到
813
00:33:41,060 --> 00:33:41,690
哪个答案?
814
00:33:41,760 --> 00:33:42,160
>> 零
815
00:33:42,910 --> 00:33:44,340
>> 大卫:对的  我将得到零
816
00:33:44,340 --> 00:33:48,600
稍微看一看:如果这是9  5除以9会得到
817
00:33:48,600 --> 00:33:51,660
0点几  如果你用两个整型数
818
00:33:51,840 --> 00:33:53,990
你舍去小数  这就是当你们
819
00:33:53,990 --> 00:33:56,420
用整型数使用这个操作的所发生的事情
820
00:33:56,420 --> 00:33:58,480
我将得到数值0乘以任何一个数字
821
00:33:58,770 --> 00:34:00,570
所以我的答案总会是0
822
00:34:00,570 --> 00:34:03,180
因此  几乎这总是错误的 对不?
823
00:34:04,130 --> 00:34:06,040
>> 但是f不是已经是一个浮点数了吗?
824
00:34:06,040 --> 00:34:07,810
所以为什么这个不是【无法辨认的声音】?
825
00:34:08,120 --> 00:34:08,940
>> 大卫:极好的问题
826
00:34:08,940 --> 00:34:12,230
所以f不是已经是个浮点数了吗?
827
00:34:12,490 --> 00:34:16,070
是那样的  但是特别地  因为我这里加上了括号
828
00:34:16,070 --> 00:34:19,150
因为我指明  "f减去32
829
00:34:19,410 --> 00:34:22,720
然后它乘以左边的那个除法的结果"
830
00:34:23,550 --> 00:34:26,150
正像是在小学你做除法和乘法的时候
831
00:34:26,150 --> 00:34:28,610
你毫不含糊地从左到右
832
00:34:28,610 --> 00:34:29,570
按顺序做运算
833
00:34:29,790 --> 00:34:32,160
先做5除以9
834
00:34:32,430 --> 00:34:34,450
那个答案总归是0
835
00:34:34,640 --> 00:34:37,540
是的  f是一个浮点数  但是那个解决方案太迟了
836
00:34:37,880 --> 00:34:38,970
我们应该在次之前把问题解决
837
00:34:39,390 --> 00:34:41,040
>> 我如何调整那个括号?
838
00:34:41,730 --> 00:34:42,970
我可以把它放前面吗?
839
00:34:43,040 --> 00:34:45,010
>> 大卫:是的  你可以
840
00:34:45,070 --> 00:34:49,510
如果你那样做  如果我们把 (f-32)放前面
841
00:34:49,790 --> 00:34:52,130
那将会给我们一个浮点数答案
842
00:34:52,330 --> 00:34:54,190
因为f是浮点数
843
00:34:54,450 --> 00:34:58,040
然后我们把这个浮点数乘以5
844
00:34:58,040 --> 00:34:59,500
那是浮点数乘以整型数
845
00:34:59,500 --> 00:35:00,090
那是可以的
846
00:35:00,090 --> 00:35:01,250
那将会给我们一个浮点数
847
00:35:01,400 --> 00:35:03,330
然后我除以一个整型数--
848
00:35:03,330 --> 00:35:05,950
那是可以的因为现在为止  我们在之前已经
849
00:35:05,950 --> 00:35:07,940
引入了一个浮点数  你是对的
850
00:35:07,940 --> 00:35:10,130
这个问题只会发生在
851
00:35:10,200 --> 00:35:11,880
当你用一个整型数除以一个整型数的时候
852
00:35:11,960 --> 00:35:15,160
并且那个操作是在其它操作之前的
853
00:35:15,220 --> 00:35:16,470
你将得到一个错误答案 请说?
854
00:35:16,530 --> 00:35:17,810
>> 这是不是只对除法起作用?
855
00:35:17,880 --> 00:35:20,940
如果你只是减去32  这是没有关系的--
856
00:35:21,040 --> 00:35:21,870
>> 大卫:F减去32?
857
00:35:21,870 --> 00:35:23,580
没关系  那没有问题
858
00:35:23,580 --> 00:35:27,690
这里实际上是乘法和
859
00:35:29,100 --> 00:35:31,390
除法引起了那个问题 请说?
860
00:35:32,090 --> 00:35:34,270
>> 如果不用9 0  你可以在把"float"放到
861
00:35:34,470 --> 00:35:35,930
括号里吗?
862
00:35:36,040 --> 00:35:36,850
>> 大卫:可以 绝对的
863
00:35:36,850 --> 00:35:38,940
所以我推荐可选择的应用中的一个好的
864
00:35:38,940 --> 00:35:40,160
我本可以这样做
865
00:35:40,600 --> 00:35:43,390
我之所以没有这样做是因为
866
00:35:43,390 --> 00:35:45,430
现在我看着这个  它是我有点迷惑了
867
00:35:45,430 --> 00:35:47,440
甚至是对于某些已经写了一段时间程序的人来说
868
00:35:47,660 --> 00:35:49,040
对我来说括号太多了
869
00:35:49,040 --> 00:35:50,020
所以我找了其它的方法
870
00:35:50,060 --> 00:35:52,320
你们也可以完全那样做 是吗?
871
00:35:53,040 --> 00:35:54,770
>> 好的  你上周讲了很多这个
872
00:35:55,040 --> 00:35:56,570
你们为什么写代码?
873
00:35:57,070 --> 00:36:00,970
因为你没有说你可以写像%f这样的?
874
00:36:01,150 --> 00:36:04,110
>> 大卫:%f--好问题
875
00:36:04,420 --> 00:36:06,810
所以我们讨论了"printf"  这个函数的唯一目的
876
00:36:06,810 --> 00:36:09,040
是把一些输入打印到
877
00:36:09,040 --> 00:36:09,870
屏幕上
878
00:36:10,220 --> 00:36:13,380
printf还支持"格式字符串"
879
00:36:13,380 --> 00:36:14,590
他们只是占位符
880
00:36:15,000 --> 00:36:16,280
但是这是个不同的环境
881
00:36:16,950 --> 00:36:20,270
这里我的确需要告诉计算机  "给我一些字节内存
882
00:36:20,370 --> 00:36:23,560
来存储一个值  那个值将是
883
00:36:23,560 --> 00:36:24,820
浮点型的数值"
884
00:36:25,250 --> 00:36:26,660
>> 对于不是打印输出的
885
00:36:26,860 --> 00:36:27,740
你需要写出代码吗?
886
00:36:28,290 --> 00:36:30,360
>> 大卫:在一个特定的时间  我将需要
887
00:36:30,360 --> 00:36:31,790
声明float类型这样的变量
888
00:36:31,790 --> 00:36:34,460
那样我就可以把它打印出来
889
00:36:35,030 --> 00:36:38,450
像是格式化优点的插入值
890
00:36:39,110 --> 00:36:41,910
所以这两个故事都涉及到浮点类型
891
00:36:42,150 --> 00:36:45,900
但是只有那样我们才能真正地分配到内存
892
00:36:47,030 --> 00:36:48,200
有其他的问题吗?
893
00:36:48,790 --> 00:36:50,740
好的  让我们来运行它
894
00:36:50,740 --> 00:36:52,950
看下这个底部  这个是相当随意的
895
00:36:52,950 --> 00:36:55,230
但我选择把我的字符串格式化成这样:
896
00:36:55,630 --> 00:36:58,570
所以在这个底部我打印输出% 1f
897
00:36:59,120 --> 00:37:01,810
提醒一下  这是一个只打印出
898
00:37:01,810 --> 00:37:03,680
小数点后一位的方法
899
00:37:04,010 --> 00:37:05,820
然后我将打印大写字母F
900
00:37:05,880 --> 00:37:12,130
使其比较美观的  等于另一个% 1f C
901
00:37:12,340 --> 00:37:15,310
所以我滚动到右边  我应当看到一个逗号
902
00:37:15,370 --> 00:37:17,340
在右引号的右边  然后这两个值是多少?
903
00:37:17,340 --> 00:37:18,540
>> 【无法辨认的声音】
904
00:37:18,540 --> 00:37:23,670
>> 大卫:"f  c"因为我想告诉printf  "在那些占位符
905
00:37:23,940 --> 00:37:27,140
和那个格式下打印这些值"
906
00:37:27,140 --> 00:37:28,770
让我们继续来编译它
907
00:37:28,770 --> 00:37:33,220
所以我将继续来编译f2c
908
00:37:33,220 --> 00:37:35,240
这是我给这个程序取的名字
909
00:37:35,240 --> 00:37:37,780
现在我将运行f2c
910
00:37:37,780 --> 00:37:39,760
现在输入华氏温度--
911
00:37:39,760 --> 00:37:43,140
好的  让我们选一个简单的  像212
912
00:37:43,370 --> 00:37:46,690
回车  确实等于100摄氏度
913
00:37:46,730 --> 00:37:51,450
让我们试一下另一个我们知道的  32  那是等于0
914
00:37:51,550 --> 00:37:53,800
可以推测  如果我们反复地做这个
915
00:37:53,910 --> 00:37:56,760
我们会得到类似的正确的答案
916
00:37:57,490 --> 00:37:58,840
好的  有问题吗?
917
00:37:59,470 --> 00:37:59,580
你说?
918
00:38:00,270 --> 00:38:01,730
>> 对于printf  你也对它使用printf吗?
919
00:38:02,300 --> 00:38:06,970
你也可以用GetString【无法辨认的声音】?
920
00:38:07,050 --> 00:38:08,440
>> 大卫:好问题  简单回答:不行
921
00:38:08,440 --> 00:38:10,640
所以你能够用GetString来打印答案吗?
922
00:38:10,680 --> 00:38:12,930
不行  所以我们故意在CS50的函数库中
923
00:38:13,130 --> 00:38:16,370
根据函数的作用来给他们命名
924
00:38:16,370 --> 00:38:18,260
所以当你有一个叫做GetSting的函数
925
00:38:18,490 --> 00:38:21,460
它的意思是从用户那获得一个字符串--
926
00:38:21,520 --> 00:38:22,940
提示用户输入一个字符串--
927
00:38:23,310 --> 00:38:25,130
然而printf的确是用来打印的
928
00:38:25,130 --> 00:38:26,720
不是在纸上  而是在屏幕上
929
00:38:27,400 --> 00:38:29,780
所以很大程度上函数的名字指明了
930
00:38:29,950 --> 00:38:31,180
或暗示了它们的功能
931
00:38:32,050 --> 00:38:32,400
好的
932
00:38:32,610 --> 00:38:36,350
让我们继续来介绍其他几个功能
933
00:38:36,350 --> 00:38:38,360
以便我们最终能开始写程序
934
00:38:38,360 --> 00:38:41,040
那样可以打印图表或与用户交互
935
00:38:41,090 --> 00:38:41,970
打游戏之类的
936
00:38:42,130 --> 00:38:43,650
好的  大部分的这些东西
937
00:38:43,710 --> 00:38:44,750
的确对应Scrtch来说是 非常类似的
938
00:38:44,820 --> 00:38:47,080
结果在C语言中  你们完全可以表示出环境的概念
939
00:38:47,080 --> 00:38:49,560
一个分支  一个三岔路口
940
00:38:49,790 --> 00:38:53,400
这个语法看起来使人想起Scratch
941
00:38:53,400 --> 00:38:55,910
那里有一个这种形状的程序块
942
00:38:56,200 --> 00:38:58,840
但是你必须说明"if"后面跟着一个空格
943
00:38:59,220 --> 00:39:02,440
跟着一个括号  一个你需要核对的布尔表达式
944
00:39:02,440 --> 00:39:03,970
--还有更多的
945
00:39:04,220 --> 00:39:07,660
花括号是C语言的一个方式
946
00:39:07,660 --> 00:39:09,250
用来做一个像这样的程序块
947
00:39:09,250 --> 00:39:10,460
所以你可以把代码写在里面
948
00:39:10,730 --> 00:39:12,260
所以左花括号后面跟着
949
00:39:12,260 --> 00:39:14,960
右花括号  这意味着花括号里面所有的代码
950
00:39:14,960 --> 00:39:17,340
都应该是要被执行的
951
00:39:17,340 --> 00:39:21,320
但只有当第一个条件是正确的
952
00:39:21,570 --> 00:39:24,260
你们才可以在C语言中使用这些东西 所以如果你想做
953
00:39:24,380 --> 00:39:27,460
--让我把这个弄得更简单点--
954
00:39:27,750 --> 00:39:31,800
如果你想把这些代码堆集在一起  在一个情况中
955
00:39:31,890 --> 00:39:34,590
或在另一个情况中处理  你能够像这样把他们集在一起吗?
956
00:39:34,590 --> 00:39:36,820
请注意  不像Scratch  在那里
957
00:39:36,820 --> 00:39:39,070
你们其中某些人可能认识到它变得有点丑
958
00:39:39,070 --> 00:39:41,520
你有一个"if else"然后这里又另一个
959
00:39:41,520 --> 00:39:43,610
那里又有一个  代码就像这样开始跳转 跳转再跳转
960
00:39:43,610 --> 00:39:44,740
它开始变得有点凌乱了
961
00:39:44,990 --> 00:39:47,650
用C语言  你只要把代码排在这里的左边
962
00:39:47,800 --> 00:39:48,520
因为只是文本
963
00:39:49,080 --> 00:39:51,750
所以如果我们有第三个  我们可以像这样引进它
964
00:39:51,750 --> 00:39:54,690
这样代码就排得漂亮多了
965
00:39:54,850 --> 00:39:58,960
此外  如果你只有一行代码
966
00:39:58,960 --> 00:40:00,920
需要执行  在Scratch 术语中叫做
967
00:40:01,000 --> 00:40:02,230
一句代码
968
00:40:02,540 --> 00:40:04,630
你就不需要使用花括号了
969
00:40:04,630 --> 00:40:07,830
如果那个条件成立  你有两行或更多行的代码时需要执行时
970
00:40:07,830 --> 00:40:11,380
你就需要花括号
971
00:40:11,380 --> 00:40:13,610
但是现在  简单起见  你可以
972
00:40:13,610 --> 00:40:17,780
养成每次都使用花括号的习惯
973
00:40:18,330 --> 00:40:18,440
请说?
974
00:40:21,960 --> 00:40:23,310
>> 你说你在if和括号之间用了个空格
975
00:40:23,340 --> 00:40:23,970
那有什么影响吗?
976
00:40:24,350 --> 00:40:25,040
>> 大卫:没有
977
00:40:25,040 --> 00:40:26,070
好的  所以你捕捉到我
978
00:40:26,070 --> 00:40:28,800
以教育目的用了个善意的谎言
979
00:40:28,800 --> 00:40:31,940
所以那个问题是:我们在if和括号之间
980
00:40:31,940 --> 00:40:32,990
需不需要空格呢?
981
00:40:33,310 --> 00:40:35,460
从简单的技术上说是不需要的
982
00:40:35,460 --> 00:40:39,140
作为一个格式风格问题  那是非常必要的
983
00:40:39,140 --> 00:40:41,200
那样可读性更好
984
00:40:41,200 --> 00:40:43,230
所以这是以个贯穿整个课程的话题
985
00:40:43,230 --> 00:40:46,020
至此 人们大都是把注意力集中于正确性
986
00:40:46,090 --> 00:40:49,350
观点上:你的代码是不是根据你的意愿
987
00:40:49,540 --> 00:40:51,030
并按照你的要求来执行呢?
988
00:40:51,240 --> 00:40:53,860
但是另外两个中心线  按照教学大纲我们将探究
989
00:40:53,860 --> 00:40:54,980
课程中格外的一些细节
990
00:40:54,980 --> 00:40:56,350
这些中心线是跟
991
00:40:56,350 --> 00:40:58,890
我们评估你们的设计论文是一致的
992
00:40:59,140 --> 00:41:01,510
换句话说  这个执行得怎么样?
993
00:41:01,580 --> 00:41:04,350
你是不是复制粘贴50次
994
00:41:04,700 --> 00:41:07,530
当你可以用一个循环来循环50次呢?
995
00:41:07,530 --> 00:41:09,460
所以那是个好模式 坏设计的问题
996
00:41:09,700 --> 00:41:11,430
还有第三个中心线叫做"设计风格"
997
00:41:11,670 --> 00:41:14,200
那是一个主观的审美学的观念
998
00:41:14,630 --> 00:41:18,000
所以你们将看到在教科书中  我写的程序中
999
00:41:18,000 --> 00:41:20,440
研究生助教和课程辅导员写的代码中
1000
00:41:20,730 --> 00:41:23,130
有着不同的编程风格  比如--
1001
00:41:23,130 --> 00:41:26,610
这是一个不错的权威的范例--很多人
1002
00:41:26,930 --> 00:41:30,950
特别是写C语言程序的人  把他们的花括号
1003
00:41:30,950 --> 00:41:35,660
放在第一行  直观上有人不太熟悉
1004
00:41:35,660 --> 00:41:37,170
为什么这个会更好?
1005
00:41:37,700 --> 00:41:40,480
因为这里没有一个固定的答案
1006
00:41:40,480 --> 00:41:43,220
但是为什么这个方法更好点呢? 你说?
1007
00:41:44,580 --> 00:41:44,950
>> 它好像更【无法辨认的声音】
1008
00:41:44,950 --> 00:41:45,910
>> 大卫:是的  它更实用点  对不对?
1009
00:41:45,910 --> 00:41:47,830
这样可以少占有三行空间
1010
00:41:47,830 --> 00:41:49,790
当我开始写很多行代码的时候  你们懂的
1011
00:41:49,790 --> 00:41:51,660
这明显是有用的  当你可以在屏幕上看到更多的代码
1012
00:41:51,660 --> 00:41:53,520
而不用滚动屏幕
1013
00:41:53,760 --> 00:41:57,310
所以我要主张  作为在我生命中的实践经验
1014
00:41:57,310 --> 00:41:59,650
和教学的资格  真诚地说
1015
00:41:59,650 --> 00:42:00,810
我认为这个是更具有可读性的
1016
00:42:00,810 --> 00:42:03,480
而且这个对于Scratch来说是也是更有结构性的
1017
00:42:03,740 --> 00:42:05,670
但是请认识到  用这些决定
1018
00:42:05,810 --> 00:42:07,350
它将会有风格上的问题
1019
00:42:07,350 --> 00:42:08,670
所以你们将会被指出
1020
00:42:08,670 --> 00:42:13,850
在习题集1中  PDF是我们CS50课堂
1021
00:42:14,030 --> 00:42:15,320
编码风格指南
1022
00:42:15,320 --> 00:42:18,880
你将看到用绿色方式高亮显示的是编程的好的方法
1023
00:42:18,880 --> 00:42:22,010
你将看到用黄色方式高亮显示的是可以做的方法--
1024
00:42:22,010 --> 00:42:22,950
只是保证你们在做这个
1025
00:42:22,950 --> 00:42:24,200
因为你们知道你们在干什么
1026
00:42:24,200 --> 00:42:26,880
并且你喜欢做这个的方式 像这样的红色的东西
1027
00:42:26,880 --> 00:42:29,620
出人意外地  我经常看到因为我们都没有教这个
1028
00:42:29,620 --> 00:42:30,950
但我们看到了这样的作业:
1029
00:42:31,480 --> 00:42:33,700
像这样缩进的不会帮助任何人
1030
00:42:33,790 --> 00:42:36,100
正如你们看到的上面红色的地方
1031
00:42:36,170 --> 00:42:37,680
你们可以做一些疯狂的事情  因为最终
1032
00:42:37,830 --> 00:42:39,340
那个计算机并不关心
1033
00:42:39,340 --> 00:42:41,860
编译器会忽略所有的叫做
1034
00:42:41,860 --> 00:42:43,940
"优美打印"--所有的这类缩进
1035
00:42:44,190 --> 00:42:45,360
所有的这些空格--
1036
00:42:45,530 --> 00:42:47,630
只是为了我们的利益  也是你的
1037
00:42:47,630 --> 00:42:49,740
你的同事 教员的和其他人的利益
1038
00:42:49,950 --> 00:42:53,110
久而久之  你们将通过看和实践来学习到
1039
00:42:53,320 --> 00:42:56,240
这里通常有很好的方法 还行的方法
1040
00:42:56,390 --> 00:42:58,570
很烂的方法来编写代码
1041
00:42:58,670 --> 00:43:01,550
但是这是一个我们以后要练习的原则
1042
00:43:01,710 --> 00:43:09,650
为什么我们不开始休息5分钟呢?
1043
00:43:09,650 --> 00:43:11,440
好的
1044
00:43:11,590 --> 00:43:14,290
让我用这个素材写个真实的程序
1045
00:43:14,290 --> 00:43:16,740
在你们的打印输出中有几个文件
1046
00:43:16,740 --> 00:43:19,950
其中一个叫做condition1 c 我将
1047
00:43:19,950 --> 00:43:21,860
改变我的终端窗口
1048
00:43:22,190 --> 00:43:27,620
我将用Nano来打开condition1 c文件
1049
00:43:27,620 --> 00:43:29,060
实际上  我在用小技巧
1050
00:43:29,060 --> 00:43:30,310
我将用我自己专门的程序
1051
00:43:30,310 --> 00:43:31,980
那个会分类为我标出代码的颜色
1052
00:43:32,230 --> 00:43:34,070
但是那个思想是一样的 这是一个文本编辑器
1053
00:43:34,370 --> 00:43:37,000
让我们看看到底这个程序是做什么的
1054
00:43:37,000 --> 00:43:40,070
我把注释去掉了  那些双斜杠
1055
00:43:40,070 --> 00:43:41,850
右边的文字
1056
00:43:41,850 --> 00:43:44,770
所以这样你你们可以做一些思考
1057
00:43:44,770 --> 00:43:46,340
而不是阅读屏幕上的答案
1058
00:43:46,340 --> 00:43:47,770
你们的拷贝的注释
1059
00:43:47,770 --> 00:43:49,310
记录了代码做的所有事情
1060
00:43:49,740 --> 00:43:51,300
所以这里是我的代码
1061
00:43:51,690 --> 00:43:53,070
我先用printf
1062
00:43:53,070 --> 00:43:55,930
我想要一个整型数  一个冒号  和一个
1063
00:43:55,930 --> 00:43:56,980
使其更美观的空格
1064
00:43:57,230 --> 00:44:00,600
然后我声明了一个变量n  它是int型的
1065
00:44:00,950 --> 00:44:03,380
我用了一个复制操作符
1066
00:44:03,440 --> 00:44:07,620
一个等号向n中存储了什么?
1067
00:44:08,770 --> 00:44:09,380
>> 那个整型数
1068
00:44:09,380 --> 00:44:09,550
>> 大卫:那个整型数
1069
00:44:09,830 --> 00:44:12,590
所以存储在n中的是GetInt 的返回值
1070
00:44:12,590 --> 00:44:14,360
现在我把GetInt去掉了  这是什么意思?
1071
00:44:14,670 --> 00:44:16,960
好的  因为最终我们将给你们看源代码
1072
00:44:16,960 --> 00:44:19,070
那个我为GetInt而写的代码
1073
00:44:19,350 --> 00:44:22,680
但是现在假设GetInt只是使光标闪烁
1074
00:44:22,970 --> 00:44:25,310
或者是不变的--它依赖于你的电脑
1075
00:44:25,310 --> 00:44:26,390
和操作系统之类的
1076
00:44:26,610 --> 00:44:28,030
假如是那样--现在想想
1077
00:44:28,030 --> 00:44:30,610
GetInt只是使光标闪烁或
1078
00:44:30,610 --> 00:44:33,620
等待用户来输入一个"整型数"然后敲回车键
1079
00:44:33,620 --> 00:44:34,880
所以获得一个int数是什么目的?
1080
00:44:34,880 --> 00:44:37,380
如果你用GetSring来代替它  同样的:闪烁光标
1081
00:44:37,560 --> 00:44:39,290
那个函数只是等待用户来
1082
00:44:39,290 --> 00:44:42,290
输入一个单词 一个句子什么的  然后敲回车
1083
00:44:42,510 --> 00:44:45,110
我们可以看到  如果你尝试打乱我们的函数
1084
00:44:45,170 --> 00:44:48,690
当想要一个int数时我们提供sting型  或者
1085
00:44:48,690 --> 00:44:51,150
当想要一个sting数时我们提供int型  你可能会被吼叫
1086
00:44:51,150 --> 00:44:52,470
然后用户不得不重新尝试
1087
00:44:52,470 --> 00:44:54,930
所以我们植入了一些错误校验  如果你愿意
1088
00:44:54,930 --> 00:44:56,190
在我们的执行代码里
1089
00:44:56,420 --> 00:44:57,380
现在这个故事的这里
1090
00:44:57,380 --> 00:45:00,090
我获得了一个变量n  我把它存储成int型的
1091
00:45:00,380 --> 00:45:01,290
我现在在干嘛呢?
1092
00:45:01,490 --> 00:45:03,740
好的  这是其中一个条件  这些分支
1093
00:45:03,740 --> 00:45:04,800
我们在Scratch中使用了他们
1094
00:45:04,840 --> 00:45:07,610
如果n比0大  我就决定来说:
1095
00:45:07,910 --> 00:45:11,330
"你选择了一个整数  反斜杠n"  所以你把光标
1096
00:45:11,330 --> 00:45:15,040
放在下一行  另外如果n不小于0  我说:
1097
00:45:15,250 --> 00:45:17,670
"你选择一个负数  反斜杠n"
1098
00:45:17,670 --> 00:45:21,390
请注意因为我在每个分支中只有一行代码
1099
00:45:21,390 --> 00:45:24,940
显然地我省略了什么?
1100
00:45:24,940 --> 00:45:25,040
>> 【无法辨认的声音】
1101
00:45:25,040 --> 00:45:25,600
>> 大卫:花括号
1102
00:45:25,600 --> 00:45:27,440
所以我实际上不需要那个花括号
1103
00:45:27,680 --> 00:45:29,530
因为我只有一行代码
1104
00:45:29,530 --> 00:45:31,800
但是如果我的确有两行或更多的代码
1105
00:45:31,940 --> 00:45:33,510
我其实应该把花括号加上
1106
00:45:33,510 --> 00:45:34,300
为什么省略它们?
1107
00:45:34,550 --> 00:45:36,840
只是使代码更加紧凑点  像刚才那位绅士说的
1108
00:45:37,010 --> 00:45:39,810
用来空出一些空间来显示更多的内容
1109
00:45:39,810 --> 00:45:42,350
那可能是一个非常合理的决定
1110
00:45:42,590 --> 00:45:44,290
好的  这里有一个缺陷
1111
00:45:45,140 --> 00:45:46,920
机敏的人或数学家将认识到
1112
00:45:46,920 --> 00:45:49,970
这里将发生什么?
1113
00:45:49,970 --> 00:45:50,040
>>【无法辨认的声音】
1114
00:45:50,040 --> 00:45:50,130
>> 大卫:对的
1115
00:45:50,130 --> 00:45:51,920
所以0不是一个正数  也不是负数
1116
00:45:51,920 --> 00:45:53,600
在这里我只是简单地
1117
00:45:53,600 --> 00:45:56,330
说明它实际上会是负数
1118
00:45:56,330 --> 00:45:57,690
好的  我们可以修复它  对不?
1119
00:45:57,690 --> 00:46:00,550
我们看到了这个Scratch的分支结构
1120
00:46:00,770 --> 00:46:03,320
我们看到刚才在幻灯片中  了解到  我们不需要
1121
00:46:03,320 --> 00:46:06,170
用一个else  也不只是用一个if  而是用一个else if
1122
00:46:06,450 --> 00:46:09,670
然后这里我们可以检查与0等价的情况了
1123
00:46:09,900 --> 00:46:12,050
在这里正像所承诺的那样  其他的操作--
1124
00:46:12,050 --> 00:46:12,930
看起来有点怪异
1125
00:46:13,180 --> 00:46:17,020
但是因为"="已经被用来当赋值运算符了
1126
00:46:17,020 --> 00:46:20,010
用来把右边的一个值赋值给左边的变量
1127
00:46:20,400 --> 00:46:22,930
好的  我们必须提出另外一个
1128
00:46:22,930 --> 00:46:25,080
看起来符合人类思维习惯的符号
1129
00:46:25,340 --> 00:46:27,200
所以他们采用了"=="
1130
00:46:27,510 --> 00:46:29,460
所以这是相等操作符
1131
00:46:29,570 --> 00:46:33,350
然而那个单等号是一个赋值运算符
1132
00:46:33,620 --> 00:46:35,900
现在我们有三个条件--三岔路口--
1133
00:46:36,170 --> 00:46:38,870
然后这个程序的确是正确的  至少我希望是
1134
00:46:38,870 --> 00:46:42,020
让我们继续输入"make condition2"  然后敲回车
1135
00:46:42,460 --> 00:46:43,340
好的  编译通过
1136
00:46:43,340 --> 00:46:45,510
现在我将继续运行condition2
1137
00:46:45,510 --> 00:46:48,010
现在注意正如所承诺的  这里我用的是苹果电脑
1138
00:46:48,010 --> 00:46:49,630
所以我的光标不会闪烁
1139
00:46:49,870 --> 00:46:51,890
但是光标在那里等我输入
1140
00:46:51,890 --> 00:46:54,340
什么都不会发生直到我输入东西
1141
00:46:54,340 --> 00:46:56,380
我们输:"David"
1142
00:46:57,610 --> 00:46:59,370
好的  显然那不是一个int数
1143
00:46:59,740 --> 00:47:02,100
我不用int数  正如预期的那样  它开始对我大叫
1144
00:47:02,100 --> 00:47:03,400
并且说"重试"
1145
00:47:03,400 --> 00:47:04,810
它将会令人作呕地反复如此处理
1146
00:47:04,810 --> 00:47:08,020
直到我给它一个int数或者当我认识到:"喔
1147
00:47:08,020 --> 00:47:09,830
我真的弄砸了这个程序
1148
00:47:09,830 --> 00:47:11,970
我不能给它所要的"
1149
00:47:12,210 --> 00:47:14,520
当你在写代码时  程序将
1150
00:47:14,520 --> 00:47:16,100
提醒这个问题  如果你不得不
1151
00:47:16,100 --> 00:47:17,990
关闭这个程序  你不需要关闭这个窗口
1152
00:47:17,990 --> 00:47:21,180
重启像那样的疯狂举动  通常你可以敲CTRL+C
1153
00:47:21,180 --> 00:47:23,690
它将会在这个地方终止那个程序
1154
00:47:23,690 --> 00:47:26,100
假使你陷入了尴尬的处境
1155
00:47:26,100 --> 00:47:28,150
不过让我们这次正确地来玩这个游戏
1156
00:47:28,460 --> 00:47:29,860
所以我想要一个整型数
1157
00:47:30,050 --> 00:47:31,720
1 2 3  回车
1158
00:47:32,010 --> 00:47:33,170
你选择了一个正数
1159
00:47:33,170 --> 00:47:36,060
让我们先在试-1 2 3
1160
00:47:36,420 --> 00:47:37,560
你们选择了一个负数
1161
00:47:37,560 --> 00:47:39,720
然后让我们在运行一次0
1162
00:47:40,040 --> 00:47:41,310
你们选择了0
1163
00:47:41,310 --> 00:47:41,990
运行很好
1164
00:47:41,990 --> 00:47:43,410
所以这个程序实际上好像
1165
00:47:43,410 --> 00:47:45,500
最终还是做了点有用的东西
1166
00:47:45,500 --> 00:47:48,460
现在让我们看一下我们还可以怎么处理它
1167
00:47:48,460 --> 00:47:51,030
好的  结果是如果你想要核对两个条件
1168
00:47:51,180 --> 00:47:52,890
你只关心其中一个是正确的
1169
00:47:53,130 --> 00:47:54,390
或另外一个是正确的
1170
00:47:54,900 --> 00:47:58,270
在现实世界中  你可能想说
1171
00:47:58,270 --> 00:48:02,460
如果你去电影院看R级电影  "你有18岁吗?
1172
00:48:02,460 --> 00:48:04,510
或者你跟随你的父母亲来的吗?"
1173
00:48:04,600 --> 00:48:07,380
所以你想要处理这个条件或这一个
1174
00:48:07,690 --> 00:48:09,670
你不想打破这些条件因为你想
1175
00:48:09,670 --> 00:48:11,070
让这些人进来或者那个家庭进来
1176
00:48:11,130 --> 00:48:13,020
不过怎么样  如果其中任何一个
1177
00:48:13,090 --> 00:48:16,190
条件成立  你可以进来或跟他们一起进来
1178
00:48:16,390 --> 00:48:18,400
在Scratch中  这个你用的程序块
1179
00:48:18,400 --> 00:48:21,080
照字面地想法来说"or"表示或者
1180
00:48:21,310 --> 00:48:23,470
在C语言中  是两个竖线
1181
00:48:23,470 --> 00:48:25,530
如果你从来没用过这些竖线  它们在
1182
00:48:25,530 --> 00:48:26,500
回车键的上面
1183
00:48:26,500 --> 00:48:28,420
你可能要按住Shift键或什么键
1184
00:48:28,460 --> 00:48:29,350
但他们是标准键
1185
00:48:29,580 --> 00:48:31,820
它是复纵线--之间没有空格
1186
00:48:32,020 --> 00:48:34,360
我最后将了解到  单一竖线的意思
1187
00:48:34,360 --> 00:48:35,060
是不同的
1188
00:48:35,060 --> 00:48:37,790
所以复纵线意思是  如果这两个条件之一--
1189
00:48:37,790 --> 00:48:40,760
或者两个都--是成立的  那就继续
1190
00:48:40,760 --> 00:48:42,030
执行后面的代码
1191
00:48:42,320 --> 00:48:44,930
如果你想保证两个条件都成立
1192
00:48:45,350 --> 00:48:48,060
或者它们两个都必须为真值  才能执行一些代码
1193
00:48:48,260 --> 00:48:49,530
那就使用"&&"
1194
00:48:49,530 --> 00:48:51,050
这使我们想到了那个and的概念
1195
00:48:51,050 --> 00:48:54,370
在Scratch中  你们大概看到那个关键字
1196
00:48:54,370 --> 00:48:56,120
"and"在其中一个程序块中
1197
00:48:56,770 --> 00:48:58,500
让我们看看我们怎样使用它
1198
00:48:58,670 --> 00:49:01,550
这个有一个叫做nonswitch c的文件
1199
00:49:01,700 --> 00:49:02,950
在你们的打印资料里
1200
00:49:03,340 --> 00:49:06,190
让我们翻下来看看我们接下来可以做什么
1201
00:49:06,190 --> 00:49:07,850
我们的程序可以变得有点有趣
1202
00:49:07,850 --> 00:49:10,550
根据我们的输入做一些判断
1203
00:49:10,550 --> 00:49:13,330
所以在顶部  我像之前那样对同样的东西进行编码:
1204
00:49:13,610 --> 00:49:16,420
"给我一个1到10的整数"  或者
1205
00:49:16,490 --> 00:49:17,950
"给我一个1到10的整数"--
1206
00:49:17,950 --> 00:49:18,920
这次有点不同
1207
00:49:19,210 --> 00:49:21,240
然后我调用GetInt  它将
1208
00:49:21,240 --> 00:49:22,930
为我处理一些麻烦的用户
1209
00:49:22,930 --> 00:49:25,050
如果他们键入了不合法的字符  它将对他们叫喊
1210
00:49:25,050 --> 00:49:27,560
然后叫他们重试  最终我将
1211
00:49:27,560 --> 00:49:30,150
得到一个int数  它是存储在n中的 好的
1212
00:49:30,150 --> 00:49:33,250
如果我的确想要根据它的量级来判定这个数字
1213
00:49:33,430 --> 00:49:37,870
好的  现在我可以指明  "是否n大于等于1"
1214
00:49:38,170 --> 00:49:41,530
所以在你们的键盘上  在下面没有一个大于号且
1215
00:49:41,530 --> 00:49:43,200
下面是一个减号的键("≥")
1216
00:49:43,310 --> 00:49:45,210
即使你们可能在微软Word中有它
1217
00:49:45,210 --> 00:49:46,520
但那也不没有关系
1218
00:49:46,520 --> 00:49:48,930
在C和大部分的编程语言中  如果你需要表示大于等于
1219
00:49:48,930 --> 00:49:51,870
在">"号后边加上一个"="
1220
00:49:51,870 --> 00:49:54,840
中间不要空格  那使我们联想到同样的想法
1221
00:49:55,260 --> 00:49:59,530
所以n大于等于1  并且n小于等于3
1222
00:49:59,530 --> 00:50:01,910
我们武断的判定它为
1223
00:50:01,910 --> 00:50:03,120
一个小的数字
1224
00:50:03,420 --> 00:50:07,350
否则如果n大于(等于)4  并且n小于(等于)6--
1225
00:50:07,520 --> 00:50:11,860
我们叫它为中间数--否则如果n大于等于7
1226
00:50:11,860 --> 00:50:13,700
小于等于10--我们叫它为"大数"--
1227
00:50:13,700 --> 00:50:18,160
如果用户键入了0或者-10或20或其它的
1228
00:50:18,320 --> 00:50:21,320
让我们用一个广泛的else子句  只需要说
1229
00:50:21,320 --> 00:50:23,220
"你选了一个非法的数字"
1230
00:50:23,830 --> 00:50:26,700
所以在这里  现在代码变得更有趣了
1231
00:50:26,700 --> 00:50:28,470
但是它也显得有点臃肿
1232
00:50:28,470 --> 00:50:30,670
代码变得稍微有点长了
1233
00:50:30,670 --> 00:50:34,790
有没有其它的可选择的语法来实施这个想法呢?
1234
00:50:34,790 --> 00:50:36,310
在Scratch中你可能已经意识到
1235
00:50:36,430 --> 00:50:38,330
"我可以用这一段代码来
1236
00:50:38,330 --> 00:50:40,130
执行我的程序  不过这有点感觉到
1237
00:50:40,130 --> 00:50:41,770
我可以用这些代码段来代替"--
1238
00:50:41,770 --> 00:50:43,990
那绝对是编程中的一个情况
1239
00:50:43,990 --> 00:50:46,190
即使今天乃至整个课程中
1240
00:50:46,190 --> 00:50:48,690
你们将了解到很多的结构  你将发现
1241
00:50:49,020 --> 00:50:52,330
这里有很多的方法来处理一些事情
1242
00:50:52,490 --> 00:50:55,350
这将引导你们做更好的设计
1243
00:50:55,350 --> 00:50:58,360
随着时间的推移  从两个不同的选择中
1244
00:50:58,360 --> 00:50:59,990
选择一个更好的
1245
00:50:59,990 --> 00:51:02,490
所以C语言支持叫做switch的东西
1246
00:51:02,570 --> 00:51:03,790
一个开关结构
1247
00:51:04,060 --> 00:51:08,100
这个东西是不错的  因为它不用"if"和"and and"
1248
00:51:08,100 --> 00:51:09,470
或者"or or"所有的这些
1249
00:51:09,730 --> 00:51:12,220
你可以用枚举来更清楚地表达它
1250
00:51:12,220 --> 00:51:14,750
虽然表面上它用了更多的空格
1251
00:51:15,120 --> 00:51:16,710
但程序的上半部分是一样的
1252
00:51:16,710 --> 00:51:18,360
"给我一个1到10的正数"
1253
00:51:18,630 --> 00:51:19,840
我得到一个整数并把它存储
1254
00:51:20,090 --> 00:51:25,000
到n中 switch语句的圆括号里可以是一个整数
1255
00:51:25,290 --> 00:51:28,320
或者一个字符或其他的基本类型
1256
00:51:28,770 --> 00:51:30,780
所以现在假使它是一个整数或字符
1257
00:51:31,060 --> 00:51:34,310
然后我们在花括号中要做的是
1258
00:51:34,420 --> 00:51:38,360
逐行地列举接下来我想要
1259
00:51:38,790 --> 00:51:40,180
应用的代码
1260
00:51:40,430 --> 00:51:43,030
所以这些代码到最后的实现上  功能是
1261
00:51:43,030 --> 00:51:45,790
完全相同的  nonswitch c
1262
00:51:46,090 --> 00:51:47,880
但是我想要再次强调一下
1263
00:51:47,880 --> 00:51:50,440
"在case 1"  那是当n等于1时
1264
00:51:50,870 --> 00:51:52,610
或者当case 2适用--
1265
00:51:52,610 --> 00:51:55,700
当n等于2或者当n等于3  它将做什么?
1266
00:51:55,700 --> 00:51:58,910
我继续打印一个小数字
1267
00:51:59,110 --> 00:52:00,520
但是现在我需要用"break"
1268
00:52:00,870 --> 00:52:02,070
Break是另一个关键字
1269
00:52:02,070 --> 00:52:04,570
你可能再Scratch中使用了类似的东西  可能是Stop
1270
00:52:04,570 --> 00:52:05,630
或者之类的东西
1271
00:52:05,630 --> 00:52:08,040
用来在一个循环或结构中中断我们正在做的东西
1272
00:52:08,290 --> 00:52:10,630
我需要中断  因为否则
1273
00:52:10,630 --> 00:52:12,690
switch的想法将会失败
1274
00:52:12,910 --> 00:52:15,280
一旦其中一个成立  它将会开始执行
1275
00:52:15,280 --> 00:52:18,410
那些代码直到你叫它们终止
1276
00:52:18,780 --> 00:52:21,640
现在在最下面  我们会看到一个default 分支
1277
00:52:21,640 --> 00:52:23,570
当它不在你列出的所有情况中
1278
00:52:23,570 --> 00:52:26,820
为了处理其他的情况  你可以用"default:"
1279
00:52:27,360 --> 00:52:30,690
这里我可以用break来终止这段代码  但是它是有点
1280
00:52:30,690 --> 00:52:33,640
不必要的  因为我已经在这个花括号的
1281
00:52:33,640 --> 00:52:35,040
底部了  就这样了
1282
00:52:35,040 --> 00:52:37,350
总之这里没有更多的代码需要执行了
1283
00:52:37,650 --> 00:52:38,600
哪一个更好呢?
1284
00:52:38,960 --> 00:52:40,690
坦白讲  这个看起来有点丑
1285
00:52:40,690 --> 00:52:42,800
你需要翻滚屏幕来看它
1286
00:52:43,020 --> 00:52:45,630
但是当你看是写程序时  特别是当我们
1287
00:52:45,630 --> 00:52:47,080
使用基于网络的东西  你想要
1288
00:52:47,080 --> 00:52:48,270
检查用户的输入--
1289
00:52:48,270 --> 00:52:49,750
它是合法的吗?它是不是一个电子邮箱地址?
1290
00:52:49,750 --> 00:52:51,030
所有的这些场景--
1291
00:52:51,310 --> 00:52:53,960
实际上它常常是有用的  当你用枚举结构列举它们
1292
00:52:53,960 --> 00:52:57,310
或者用它来快速地来说出它们
1293
00:52:57,870 --> 00:52:58,210
好的
1294
00:52:58,210 --> 00:53:00,250
嗯  我们在Scratch中看到了循环
1295
00:53:00,590 --> 00:53:03,220
现在让我们看看我们如何用它们来处理
1296
00:53:03,220 --> 00:53:05,170
那个登记人数的小图表
1297
00:53:05,470 --> 00:53:06,870
这是用for循环语句
1298
00:53:07,260 --> 00:53:09,020
在C和很多语言中
1299
00:53:09,060 --> 00:53:11,470
PHP和JavaScript对我们来说几乎看起来是一样的
1300
00:53:11,470 --> 00:53:14,630
在这个期末  你们可以用三个设计来实现
1301
00:53:14,850 --> 00:53:17,660
循环的思想:一个叫做for循环
1302
00:53:17,870 --> 00:53:19,810
我们即将要看到 一个是while循环
1303
00:53:20,120 --> 00:53:21,720
还一个叫做do while循环
1304
00:53:22,030 --> 00:53:24,760
本质上  Scratch有相同的思想  但是他们叫做repeat
1305
00:53:25,120 --> 00:53:27,560
和forever和一些其它的选择
1306
00:53:27,810 --> 00:53:29,540
所以同一个思想  不同的术语
1307
00:53:29,580 --> 00:53:30,950
实现稍微有点不同
1308
00:53:31,310 --> 00:53:32,850
所以这个程序是干嘛的呢?
1309
00:53:33,120 --> 00:53:36,810
嗯  main函数  首先声明了一个循环从这里开始
1310
00:53:37,090 --> 00:53:39,350
然后在for关键字后面的括号里
1311
00:53:39,350 --> 00:53:40,610
有三个部分
1312
00:53:40,920 --> 00:53:43,110
每个部分用冒号隔开
1313
00:53:43,110 --> 00:53:46,490
最左边的是第一部分 然后第二 第三部分
1314
00:53:46,810 --> 00:53:49,530
我们一般看到的这个结构可以这样概括
1315
00:53:49,530 --> 00:53:52,120
如果这个帮助我们描绘出一个漂亮的记忆画面
1316
00:53:52,390 --> 00:53:54,650
第一个事情是我们叫做的"初始化"
1317
00:53:54,880 --> 00:53:55,800
这个代码是
1318
00:53:55,800 --> 00:53:57,750
在所有事情发生之前执行的
1319
00:53:57,750 --> 00:53:59,950
你可以初始化一个变量  像0用来
1320
00:54:00,130 --> 00:54:01,810
计数的或者诸如此类的
1321
00:54:02,340 --> 00:54:05,310
"条件  "这个在两个分号的中间
1322
00:54:05,310 --> 00:54:08,280
它将迭代地检查这个循环的条件
1323
00:54:08,420 --> 00:54:13,270
一旦这个条件或这些条件不成立
1324
00:54:13,270 --> 00:54:15,180
整个循环终止
1325
00:54:15,560 --> 00:54:17,720
所以不像Scratch  你大致上需要用
1326
00:54:17,720 --> 00:54:21,130
"repeat"10次或更多  或者需要不断地使用当它
1327
00:54:21,130 --> 00:54:22,900
是死循环时
1328
00:54:22,900 --> 00:54:26,920
你们能够指定出一个有限的迭代次数--
1329
00:54:26,920 --> 00:54:29,780
像我15年前学的  有穷的是重要的
1330
00:54:30,080 --> 00:54:33,170
所以你们可以指定一个条件来表示有穷的次数
1331
00:54:33,170 --> 00:54:33,980
我们等下将看到
1332
00:54:34,070 --> 00:54:35,200
最后  更新
1333
00:54:35,470 --> 00:54:37,340
这不是一个好事情  如果你只是循环
1334
00:54:37,520 --> 00:54:38,750
检查一些条件
1335
00:54:38,890 --> 00:54:41,080
但是永远不要改变世界上的国家
1336
00:54:41,080 --> 00:54:43,460
如果你不通过增加或减少它来改变一些变量
1337
00:54:43,460 --> 00:54:45,210
--如果你不改变什么
1338
00:54:45,480 --> 00:54:48,440
大概那个条件永远不会变成错误的
1339
00:54:48,440 --> 00:54:50,730
或相反的  所以你将得到一个无限循环
1340
00:54:50,820 --> 00:54:53,560
那可能是你的目标  但可能也不是
1341
00:54:53,560 --> 00:54:55,090
所以在实践中我们怎么使用它呢?
1342
00:54:55,840 --> 00:54:58,220
可能最通常的方法是使用一个
1343
00:54:58,220 --> 00:55:02,590
for循环  使i等于0  然后迭代地将i增加到一个特定的值
1344
00:55:02,590 --> 00:55:05,520
这样的话  这是非常合理的
1345
00:55:05,740 --> 00:55:07,600
使用一个变量"i"  即使
1346
00:55:07,600 --> 00:55:09,200
那个表达了很少的信息
1347
00:55:09,430 --> 00:55:12,430
如果整个目标是作为一个索引  从0到1
1348
00:55:12,430 --> 00:55:13,490
到2  到3  到4
1349
00:55:13,610 --> 00:55:15,810
或者根据你的目的向下减少
1350
00:55:16,100 --> 00:55:20,120
所以这里声明了一个整型数  一个叫做I的整型变量
1351
00:55:20,210 --> 00:55:22,010
把它初始化为0
1352
00:55:22,510 --> 00:55:25,920
这个检查"I是不是小于等于100?
1353
00:55:25,920 --> 00:55:27,650
如果是  接着执行循环"
1354
00:55:27,880 --> 00:55:28,970
我继续循环
1355
00:55:29,140 --> 00:55:30,580
我打印"Percent complete"
1356
00:55:30,580 --> 00:55:33,060
这个看起来有点凌乱的  但是注意那里嵌入的是
1357
00:55:33,060 --> 00:55:34,450
一些类似的东西
1358
00:55:34,450 --> 00:55:36,200
%d意思是--
1359
00:55:36,200 --> 00:55:37,190
>> 【无法辨认的声音】
1360
00:55:37,190 --> 00:55:39,440
>> 大卫:是的  1或更多的数字
1361
00:55:39,500 --> 00:55:41,740
"%%"的意思是百分比
1362
00:55:41,940 --> 00:55:44,520
所以就像我们采用笨拙的方式来用反斜杠来避免一些东西
1363
00:55:44,520 --> 00:55:47,850
在这个背景下对百分号做相同的处理
1364
00:55:47,850 --> 00:55:51,410
如果你想要一个百分比常量  就用%% 然后 反斜杠 n
1365
00:55:51,810 --> 00:55:55,340
所以这个程序  如果你按照你的直觉
1366
00:55:55,340 --> 00:55:56,880
或你们面前的备忘单来执行它
1367
00:55:56,880 --> 00:55:58,710
这个程序最终会为我做什么?
1368
00:55:59,390 --> 00:56:01,970
>> 它将从1开始计数到【听不见的】
1369
00:56:02,050 --> 00:56:03,110
>> 大卫:是的  它将从0开始
1370
00:56:03,110 --> 00:56:04,280
计数到100
1371
00:56:04,420 --> 00:56:05,510
它将是一种我的
1372
00:56:05,590 --> 00:56:08,820
简单的执行进度条
1373
00:56:08,820 --> 00:56:09,850
所以让我们继续试验它
1374
00:56:09,850 --> 00:56:11,570
我将运行progress1
1375
00:56:11,850 --> 00:56:14,260
此外  它是一个有点乏力的实现
1376
00:56:14,720 --> 00:56:16,630
我们将不会再这里等待100秒来等它完成
1377
00:56:16,630 --> 00:56:20,100
但是我们使用循环  我们更新一个变量
1378
00:56:20,100 --> 00:56:22,510
我们把它排成一个漂亮的格式
1379
00:56:22,620 --> 00:56:24,530
所以  最终  100行代码之后
1380
00:56:24,530 --> 00:56:25,860
它将100%完成了
1381
00:56:26,010 --> 00:56:28,330
因为在那个阶段的没有其它的代码了
1382
00:56:28,530 --> 00:56:31,150
这个程序将以一种比较好的方式自然地退出 请说?
1383
00:56:31,150 --> 00:56:32,720
>> 有一种方法使它完成的百分比
1384
00:56:32,720 --> 00:56:35,970
自然地停在那个相同的地方吗?
1385
00:56:36,420 --> 00:56:37,200
>> 大卫:完全可以
1386
00:56:37,200 --> 00:56:39,120
你们能够使百分比在同一个地方停住吗?
1387
00:56:39,120 --> 00:56:40,830
因为请注意这最终将是一个问题
1388
00:56:40,830 --> 00:56:43,070
你从1开始  那个比较广泛 然后它增加到10
1389
00:56:43,130 --> 00:56:44,670
最终它将增加到100
1390
00:56:44,870 --> 00:56:46,940
所以如果你真的到最后  事物不会以一种完美格式
1391
00:56:46,940 --> 00:56:47,990
来排列
1392
00:56:48,210 --> 00:56:49,620
结果你可以
1393
00:56:49,620 --> 00:56:53,430
你可以在d之前指定一个数字
1394
00:56:53,430 --> 00:56:55,140
你也可以在f之前制定一个数字
1395
00:56:55,410 --> 00:56:57,840
如果你不用点而只用数字
1396
00:56:58,050 --> 00:57:01,280
这个指定的长度是由
1397
00:57:01,280 --> 00:57:02,750
你插入的数字决定的
1398
00:57:02,930 --> 00:57:04,140
对应习题集1
1399
00:57:04,140 --> 00:57:06,360
我们将尊重一些网上的文档中的细节
1400
00:57:06,510 --> 00:57:07,340
但是简单的答案:是的
1401
00:57:07,420 --> 00:57:09,600
它归结于是用一个简单的数字来
1402
00:57:09,930 --> 00:57:10,930
修改字符串的格式
1403
00:57:11,040 --> 00:57:12,730
所以你们可以做一些对齐
1404
00:57:13,290 --> 00:57:14,650
>> 是睡眠【听不见的声音】?
1405
00:57:15,390 --> 00:57:16,120
>> 大卫:很好的问题
1406
00:57:16,120 --> 00:57:17,550
所以睡眠--顾名思义--
1407
00:57:17,910 --> 00:57:20,870
简单地将程序睡眠一秒钟
1408
00:57:21,010 --> 00:57:23,990
这样因为我指明了睡眠的一个时间值
1409
00:57:24,460 --> 00:57:25,600
sleep函数从哪里来?
1410
00:57:25,600 --> 00:57:28,150
嗯  我的确无意掩盖那个细节
1411
00:57:28,150 --> 00:57:30,390
在这个程序的顶端  请注意我需要列出
1412
00:57:30,390 --> 00:57:33,650
另一个头文件因为sleep没有定义在
1413
00:57:33,650 --> 00:57:35,800
CS50函数库中  它没有在
1414
00:57:35,800 --> 00:57:39,200
标准输入输出函数库中声明  它显然定义在
1415
00:57:39,200 --> 00:57:40,780
uni 标准数据库中--
1416
00:57:40,830 --> 00:57:44,940
unistd h 嗯  我到底是怎么知道的呢?
1417
00:57:45,160 --> 00:57:46,960
好的  你们在习题集1中看到--
1418
00:57:46,960 --> 00:57:48,990
为了清晰  如果你不想今天从这里
1419
00:57:48,990 --> 00:57:50,290
不安地走出去--
1420
00:57:50,290 --> 00:57:52,110
请认识到我们将会手把手地
1421
00:57:52,110 --> 00:57:53,960
采用各种各样的步骤教你们做第一个习题集
1422
00:57:54,260 --> 00:57:56,510
结果是在一个Linux系统中  这里有这样一个叫做"man"的命令
1423
00:57:56,510 --> 00:57:58,060
用来显示指南手册的
1424
00:57:58,300 --> 00:58:00,280
你可以看到文档上
1425
00:58:00,280 --> 00:58:01,280
有各种各样的函数
1426
00:58:01,560 --> 00:58:04,180
所以如果我键入"man sleep"  它将
1427
00:58:04,180 --> 00:58:06,550
给我一个叫做sleep程序的用户手册
1428
00:58:06,600 --> 00:58:09,160
但是这里有个参考信息  它使问题更清晰
1429
00:58:09,470 --> 00:58:12,150
请注意它指明在左上角sleep(1)
1430
00:58:12,490 --> 00:58:15,270
结果这个用户手册  就像一个特定名册
1431
00:58:15,270 --> 00:58:17,320
有好多章节
1432
00:58:17,640 --> 00:58:20,180
第一章大概是关于程序的
1433
00:58:20,490 --> 00:58:22,980
所以结果这个有一个sleep程序
1434
00:58:23,280 --> 00:58:25,170
就像这个有个叫做Nano的程序
1435
00:58:25,170 --> 00:58:27,300
一个叫做GCC的程序--那不是我想要的
1436
00:58:27,440 --> 00:58:30,020
我想要一个函数  那是一个小工具
1437
00:58:30,020 --> 00:58:32,190
在我程序中可以包含的一行代码
1438
00:58:32,450 --> 00:58:36,080
通常这些工具在手册的第二节
1439
00:58:36,080 --> 00:58:38,640
或第三节
1440
00:58:38,940 --> 00:58:41,070
如果我指定第三个
1441
00:58:41,290 --> 00:58:42,310
现在我在那个地方
1442
00:58:42,580 --> 00:58:44,260
此外  习题集1将带你通过这个
1443
00:58:44,260 --> 00:58:46,240
你将熟悉这些东西
1444
00:58:46,240 --> 00:58:48,570
即使第一眼它看起来是比较晦涩的
1445
00:58:48,890 --> 00:58:51,340
但长话短说  如果我想要用一个叫做sleep的功能
1446
00:58:51,670 --> 00:58:55,050
我作为程序员知道使用那个函数库--
1447
00:58:55,050 --> 00:58:55,990
上面的标题--
1448
00:58:56,340 --> 00:58:58,320
因为在这个小的大纲中它告诉我
1449
00:58:58,320 --> 00:59:00,520
我阅读那个文档  照它说的做
1450
00:59:00,520 --> 00:59:02,380
那就是我如何便于我的程序的
1451
00:59:02,380 --> 00:59:04,810
你们将正确地那样去做  采用
1452
00:59:04,810 --> 00:59:06,970
习题集1中的方法
1453
00:59:07,300 --> 00:59:09,380
所以让我使它稍微性感一点
1454
00:59:09,380 --> 00:59:11,390
所以我将向这些东西所做的挥手
1455
00:59:11,390 --> 00:59:13,610
这里的fflush(stdout) (标准输出)
1456
00:59:13,890 --> 00:59:18,200
但是我觉得这是个有点无力的实现
1457
00:59:18,380 --> 00:59:21,040
一个进度条不应该是打印100行
1458
00:59:21,040 --> 00:59:22,850
只是更新它的状态 一般地  我们
1459
00:59:22,850 --> 00:59:24,220
想看到一点生机
1460
00:59:24,520 --> 00:59:27,110
让我们继续来编译progress2
1461
00:59:27,110 --> 00:59:28,600
这次运行这个程序
1462
00:59:29,150 --> 00:59:32,930
结果  你可以把光标保持在同一行
1463
00:59:33,170 --> 00:59:35,900
并且一次次地更新同一行代码
1464
00:59:36,170 --> 00:59:39,180
不用"反斜杠n"  而用
1465
00:59:39,180 --> 00:59:42,720
更复古的 "反斜杠r"
1466
00:59:42,890 --> 00:59:44,940
它不会把光标移动到下一行  像之前我们所说的
1467
00:59:44,940 --> 00:59:47,160
它把光标移动到这行的开头
1468
00:59:47,410 --> 00:59:49,670
像一台打印机一样  循环回到开始的地方
1469
00:59:49,890 --> 00:59:53,220
所以这里我一次次地在循环中使用printf
1470
00:59:53,410 --> 00:59:56,660
但是我逐行地覆盖了我之前所写的东西
1471
00:59:57,020 --> 00:59:59,910
因为我写了一个长度相同的字符串--
1472
01:00:00,190 --> 01:00:01,460
我的字符串不会变的更短--
1473
01:00:01,700 --> 01:00:04,440
它生成一个动画幻觉
1474
01:00:04,470 --> 01:00:05,620
但是真实地  这个计算机到现在为止
1475
01:00:05,620 --> 01:00:08,040
我一次又一次用稍微不同的数字
1476
01:00:08,090 --> 01:00:10,620
绘画了相同的字符串
1477
01:00:10,620 --> 01:00:13,820
在睡眠1秒钟之后
1478
01:00:13,820 --> 01:00:13,890
你说?
1479
01:00:14,120 --> 01:00:16,410
>> 所以这里有一个斜杠字母命令
1480
01:00:16,410 --> 01:00:18,400
来printf  他们可以像
1481
01:00:18,780 --> 01:00:19,970
【听不见的】你懂我的意思吗?
1482
01:00:20,050 --> 01:00:20,570
>> 大卫:好问题
1483
01:00:20,570 --> 01:00:21,910
是否有个命令来打印?
1484
01:00:22,060 --> 01:00:24,420
没有说的那么简单
1485
01:00:24,420 --> 01:00:26,760
你绝对可以实施一些更有用的
1486
01:00:26,760 --> 01:00:29,420
和一些更愉快的东西  像我们周三或今天早些时候
1487
01:00:29,420 --> 01:00:31,660
看到的  但它不只是
1488
01:00:31,700 --> 01:00:32,720
格式化字符串
1489
01:00:33,050 --> 01:00:38,640
好的  让我们看一下这里最后一个东西
1490
01:00:38,910 --> 01:00:41,350
有改进的最后一个版本
1491
01:00:41,690 --> 01:00:43,780
除了像这样的循环之外
1492
01:00:44,100 --> 01:00:45,450
你们知道还有while循环
1493
01:00:45,520 --> 01:00:47,080
你们什么时候用这种循环  什么是时候用那种呢?
1494
01:00:47,080 --> 01:00:49,990
最终  你可以执行这个程序
1495
01:00:49,990 --> 01:00:52,450
再使用for循环的地方使用while循环
1496
01:00:52,610 --> 01:00:54,370
这只是使你的代码看起来稍微有点不同
1497
01:00:54,370 --> 01:00:56,810
可能一周之后  两周之后  为了好玩
1498
01:00:56,810 --> 01:00:59,380
你决定重新实现你的Scrtch工程
1499
01:00:59,380 --> 01:01:01,760
或者其中一小部分  它将不会是令人惊讶的--
1500
01:01:01,760 --> 01:01:04,250
本来也不应该是--如果你运行相同的游戏
1501
01:01:04,250 --> 01:01:06,570
或者是动画 亦或是用完全不同的设置
1502
01:01:06,570 --> 01:01:07,330
来运行拼图游戏
1503
01:01:07,330 --> 01:01:08,580
我们将看到相同的处理
1504
01:01:08,860 --> 01:01:12,160
所以采用while循环  你有一个很像我们之前看到过的
1505
01:01:12,220 --> 01:01:14,970
if程序块和else if 程序块的情况
1506
01:01:15,270 --> 01:01:16,780
这是一个循环的时候
1507
01:01:16,780 --> 01:01:18,940
反复检查的一个条件
1508
01:01:19,250 --> 01:01:22,560
但请注意不像for循环  如果你想声明一个变量
1509
01:01:22,680 --> 01:01:24,650
或者变大或变小一个变量
1510
01:01:24,820 --> 01:01:26,010
你需要自己完成
1511
01:01:26,010 --> 01:01:27,730
你不得不在一大段代码之上来实现它
1512
01:01:27,930 --> 01:01:29,680
你不得不在一大段代码之内来实现它
1513
01:01:29,860 --> 01:01:31,240
负担在你身上
1514
01:01:31,380 --> 01:01:33,770
你没有理解for循环的美好的小特征
1515
01:01:33,920 --> 01:01:34,690
所以我们可以看到这个
1516
01:01:34,690 --> 01:01:39,850
在progress3 c中 这个一个和progress2 c完全相同的程序
1517
01:01:39,850 --> 01:01:42,980
这是一个爱好者版本  它用
1518
01:01:42,980 --> 01:01:46,040
反斜杠r来把代码移动到行的开始
1519
01:01:46,360 --> 01:01:48,960
此外  今天让我忽略fflush 的意思
1520
01:01:48,960 --> 01:01:51,950
它解决了一点缺陷  如果我不用它
1521
01:01:52,060 --> 01:01:53,600
但是更多的是在以后当你们讨论
1522
01:01:53,600 --> 01:01:55,510
文件和创建文件时
1523
01:01:55,860 --> 01:01:57,120
请注意我在这里所做的
1524
01:01:57,380 --> 01:02:00,290
因为for循环给我提供了为变量准备的占位符
1525
01:02:00,290 --> 01:02:02,380
它们在分号之间
1526
01:02:02,380 --> 01:02:03,920
现在在while循环中  我没有这些
1527
01:02:03,920 --> 01:02:05,500
我必须自己把循环转动起来
1528
01:02:05,500 --> 01:02:09,050
所以在程序的顶端我有一个int类型的变量i
1529
01:02:09,050 --> 01:02:12,420
我需要把它初始化为0
1530
01:02:12,690 --> 01:02:15,670
现在我指明当i小于等于100
1531
01:02:15,810 --> 01:02:17,670
我写下我的代码  我休眠一分钟
1532
01:02:17,970 --> 01:02:21,610
但是这里  像我们上周看到的  鞋子穿在袜子上
1533
01:02:21,610 --> 01:02:25,910
我需要亲自明确地增加这个变量
1534
01:02:25,910 --> 01:02:28,910
现在凭感觉  你们喜欢for循环还是while循环
1535
01:02:29,460 --> 01:02:29,550
>> For循环
1536
01:02:30,880 --> 01:02:32,180
>> 大卫:是的  我很可能投票赞成for循环
1537
01:02:32,220 --> 01:02:34,310
它让人感觉更清晰点  但也要看情况
1538
01:02:34,540 --> 01:02:36,570
久而久之你们也将看到像你们在Scratch上看到的一样
1539
01:02:36,610 --> 01:02:37,970
它们有不同的方式
1540
01:02:37,970 --> 01:02:41,280
来实施不同的目的
1541
01:02:41,600 --> 01:02:43,090
现在这里还有最后一个循环类型
1542
01:02:43,370 --> 01:02:44,790
这种类型的循环
1543
01:02:45,090 --> 01:02:46,990
东西变得有点颠倒的
1544
01:02:47,030 --> 01:02:50,440
所以那个do while 结构不像其他两个那么有用
1545
01:02:50,440 --> 01:02:54,420
我可能很少用do while 循环  但常常是
1546
01:02:54,420 --> 01:02:58,120
当编制程序游戏或需要用户输入的程序是
1547
01:02:58,330 --> 01:03:00,860
需要检查用户的输入并提醒用户
1548
01:03:00,860 --> 01:03:01,620
如果他们干扰了你
1549
01:03:01,620 --> 01:03:03,110
或没有提供所期望的输入
1550
01:03:03,180 --> 01:03:04,050
现在那个是什么意思?
1551
01:03:04,570 --> 01:03:07,120
作为建议的语法  do while循环的不同之处
1552
01:03:07,120 --> 01:03:09,180
是这个结构不管怎么样
1553
01:03:09,180 --> 01:03:11,230
它会做一些事情
1554
01:03:11,230 --> 01:03:12,210
它不先检查条件
1555
01:03:12,210 --> 01:03:15,960
先做了点什么  然后它做什么?
1556
01:03:15,960 --> 01:03:16,040
>> 【听不见的声音】
1557
01:03:16,040 --> 01:03:16,860
>> 大卫:然后它检查条件
1558
01:03:16,860 --> 01:03:18,070
如果条件成立
1559
01:03:18,200 --> 01:03:19,800
然后它回头再处理一次
1560
01:03:19,800 --> 01:03:21,320
如果条件不成立  它就在那里中断
1561
01:03:21,650 --> 01:03:23,750
所以概念上  则关键的区别是
1562
01:03:23,750 --> 01:03:25,700
除了语法看起来有点不同
1563
01:03:26,010 --> 01:03:28,330
它的意思是如果你想要一段代码
1564
01:03:28,330 --> 01:03:30,490
最初无论如何都要执行
1565
01:03:30,750 --> 01:03:32,560
你就可以用do while循环
1566
01:03:32,760 --> 01:03:34,610
如果你想要先检查条件
1567
01:03:34,860 --> 01:03:35,940
你可以用while循环
1568
01:03:35,940 --> 01:03:37,170
让我们在实践中看看这个
1569
01:03:37,170 --> 01:03:40,180
我将要打开一个叫做positive1 c的程序
1570
01:03:40,300 --> 01:03:42,990
我们翻到这个有趣的部分
1571
01:03:42,990 --> 01:03:44,940
它也很短  但先看看
1572
01:03:44,940 --> 01:03:45,760
这个是干什么的
1573
01:03:46,100 --> 01:03:48,400
这里也有点难看的  这也是为什么我
1574
01:03:48,400 --> 01:03:50,340
不太喜欢这个结构  至少在C语言中
1575
01:03:50,580 --> 01:03:52,040
但是有时它是必须的
1576
01:03:52,040 --> 01:03:53,920
或者它是达到目标最简单的方法
1577
01:03:54,180 --> 01:03:57,150
我申明一个变量n 我先不给它赋值
1578
01:03:57,500 --> 01:03:58,940
所以我最好小心点
1579
01:03:58,940 --> 01:04:00,660
随后我们将看到其中一个细节
1580
01:04:00,660 --> 01:04:02,200
特别是当我们讨论安全是:
1581
01:04:02,680 --> 01:04:06,420
变量初始化失败  你们知道
1582
01:04:06,420 --> 01:04:09,970
通常这个一个不好的行为  因为如果你忘了
1583
01:04:09,970 --> 01:04:12,460
如果你写了一个程序是600行而不是6行
1584
01:04:12,860 --> 01:04:16,300
使东西保持未知状态只会自找麻烦
1585
01:04:16,300 --> 01:04:18,470
因为坏人会利用这些东西来
1586
01:04:18,470 --> 01:04:20,210
放入一些
1587
01:04:20,210 --> 01:04:21,330
你没有预料到的数据
1588
01:04:21,700 --> 01:04:23,050
但是现在让我们看看  如果他是正确的
1589
01:04:23,260 --> 01:04:24,730
逻辑上看起来是安全的
1590
01:04:24,730 --> 01:04:25,840
因为我知道在那里我做了什么
1591
01:04:25,840 --> 01:04:28,510
所以int n只是给我们分配了4个字节
1592
01:04:28,900 --> 01:04:30,420
但是它没有放任何东西在那里
1593
01:04:30,570 --> 01:04:31,490
所以让我们放点东西在那
1594
01:04:31,490 --> 01:04:33,080
做下面的:打印
1595
01:04:33,140 --> 01:04:35,150
我要求你给我一个正整数
1596
01:04:35,150 --> 01:04:36,630
好的  当我写这个的时候我的语气有点生硬
1597
01:04:36,730 --> 01:04:39,980
所以接下来我挑选CS50函数库中的函数GetInt
1598
01:04:40,100 --> 01:04:41,440
我用这个值干什么呢?
1599
01:04:41,440 --> 01:04:44,910
我把它赋值给n 我把它放回这里
1600
01:04:44,910 --> 01:04:47,730
我知道这是正确的因为我不会使用n
1601
01:04:47,800 --> 01:04:49,890
直到我给它赋值了
1602
01:04:49,890 --> 01:04:52,070
所以它有点冒险但是最终是安全的
1603
01:04:52,070 --> 01:04:53,460
因为我没用它做其它的操作
1604
01:04:53,740 --> 01:04:54,560
现在我在做什么?
1605
01:04:54,780 --> 01:04:56,070
在此时此刻
1606
01:04:56,070 --> 01:04:59,720
我现在在检查当n小于1是  我做什么?
1607
01:04:59,990 --> 01:05:01,060
这样再三地
1608
01:05:01,480 --> 01:05:03,580
所以它感觉可能有点迟缓
1609
01:05:03,800 --> 01:05:06,240
但是它指明  "只要n小于1
1610
01:05:06,240 --> 01:05:08,470
执行这段代码"
1611
01:05:08,870 --> 01:05:11,560
所以先不管用户实际上给我2
1612
01:05:11,560 --> 01:05:14,450
3 4还是其他数  这个表达式
1613
01:05:14,450 --> 01:05:18,720
"是否n小于1"将被评估为错误的
1614
01:05:18,920 --> 01:05:20,990
如果输入额是2 3 4或其它的数
1615
01:05:21,250 --> 01:05:23,760
所以这个do while 循环在检查的时候
1616
01:05:23,760 --> 01:05:26,360
直接中断了
1617
01:05:26,820 --> 01:05:28,960
现在如果我和用户有点不和谐
1618
01:05:28,960 --> 01:05:34,300
我编译正positive1   然后运行positive1
1619
01:05:34,910 --> 01:05:37,910
我再次输入"David"  嗯  它将让我重试
1620
01:05:37,910 --> 01:05:42,010
然后我键入-1 0 或-0
1621
01:05:42,050 --> 01:05:42,860
还是没有起作用
1622
01:05:42,860 --> 01:05:45,140
1--多亏了1
1623
01:05:45,140 --> 01:05:48,190
所以现在它提醒我
1624
01:05:48,410 --> 01:05:50,040
用这个版本我们是否可以做些其他的呢?
1625
01:05:50,040 --> 01:05:53,290
嗯  让我们看看这个转换  positive2 c
1626
01:05:53,520 --> 01:05:54,460
它有点不同
1627
01:05:54,680 --> 01:05:56,070
但请注意现在我变得有点兴趣了
1628
01:05:56,070 --> 01:05:58,090
并且你可能已经开始在Scratch中开始做这种事情了
1629
01:05:58,090 --> 01:05:59,940
随着你们的程序变得越复杂
1630
01:06:00,370 --> 01:06:02,890
这里我声明另一个数据类型
1631
01:06:03,210 --> 01:06:05,880
布尔值的概念是在布尔先生之后命名的
1632
01:06:05,880 --> 01:06:07,760
它是一个正确或错误的概念
1633
01:06:08,090 --> 01:06:09,900
这个实际上在C语言本身里是不存在的
1634
01:06:09,900 --> 01:06:12,420
我们把它放在CS50 函数库中
1635
01:06:12,420 --> 01:06:14,080
我们不久后会撤销那一层
1636
01:06:14,270 --> 01:06:17,160
但是在其它语言中  像Java  C++中  都有Bool数据类型
1637
01:06:17,480 --> 01:06:19,050
这是一个正确或错误的值
1638
01:06:19,290 --> 01:06:22,150
因为我们学习了好的格式风格  我将给那个变量起一个
1639
01:06:22,350 --> 01:06:26,230
能使我们联想到它的角色作用  它是满意的或不满意的
1640
01:06:26,520 --> 01:06:27,780
我把它初始化为假值
1641
01:06:28,250 --> 01:06:28,930
现在我要做什么
1642
01:06:29,120 --> 01:06:30,990
我打印出来--这个字符相互覆盖了
1643
01:06:30,990 --> 01:06:31,940
因为用的是大字体
1644
01:06:32,130 --> 01:06:34,440
我打印:"我需要你给我一个正整数"
1645
01:06:34,880 --> 01:06:35,580
我然后这样做了
1646
01:06:36,160 --> 01:06:39,890
如果GetInt的返回值比0大
1647
01:06:39,890 --> 01:06:41,690
该干什么  用简单的英语说?
1648
01:06:41,690 --> 01:06:42,260
>> 【听不清的】
1649
01:06:42,260 --> 01:06:45,930
>> 大卫:我把thankful改为true值
1650
01:06:46,130 --> 01:06:47,930
现在结合有趣的东西--
1651
01:06:47,930 --> 01:06:49,330
GetInt返回一个值
1652
01:06:49,560 --> 01:06:52,570
显然在这个程序里  我的确没有关心他是什么
1653
01:06:52,570 --> 01:06:57,560
我只关心它是大于0的  所以它满足条件
1654
01:06:57,560 --> 01:07:01,060
挑选一个函数是完全合法的  返回一个值
1655
01:07:01,060 --> 01:07:04,080
用它来做些事情而不是用它与其它的值比较
1656
01:07:04,080 --> 01:07:05,680
所以你并不需要使用赋值运算符
1657
01:07:05,680 --> 01:07:07,770
你并不需要为它声明一个特定的变量
1658
01:07:07,770 --> 01:07:09,780
如果你不关心它的实际值
1659
01:07:09,780 --> 01:07:10,980
所以我指明thankful是true值
1660
01:07:11,220 --> 01:07:13,150
到这里  我可以使用我们刚才看到的
1661
01:07:13,150 --> 01:07:14,180
其它的语法
1662
01:07:14,180 --> 01:07:17,970
我想要一直这样做  当我对用户的
1663
01:07:17,970 --> 01:07:18,900
数字不满意
1664
01:07:19,180 --> 01:07:21,880
换句话说  如果thankful在这时候还是false值
1665
01:07:22,090 --> 01:07:24,660
这表示这个条件没有实现地很好
1666
01:07:24,840 --> 01:07:26,610
所以我将再次去处理这段代码
1667
01:07:26,970 --> 01:07:28,850
现在这个版本是可以证明是更好点的
1668
01:07:28,850 --> 01:07:30,510
因为它更清晰一点
1669
01:07:30,510 --> 01:07:31,320
它更具有可读性一点
1670
01:07:31,320 --> 01:07:33,570
因为我使用了一个bool值
1671
01:07:33,570 --> 01:07:36,600
它告诉我或程序员  这是正确的或这是错误的
1672
01:07:36,920 --> 01:07:38,410
好的  让我们再捋顺一点
1673
01:07:38,690 --> 01:07:40,650
结果用一个bool表达式
1674
01:07:40,650 --> 01:07:43,370
你不需要使用等号操作符"=="了
1675
01:07:43,630 --> 01:07:45,040
你只要说出你的意思
1676
01:07:45,040 --> 01:07:47,760
这个使我们的代码变得更易读  更优雅
1677
01:07:47,980 --> 01:07:49,590
更简洁紧凑一点
1678
01:07:50,260 --> 01:07:52,960
所以这里的同样的代码--thankful被初始化为false值
1679
01:07:53,400 --> 01:07:54,520
我把它打印了
1680
01:07:55,010 --> 01:07:57,740
我检查了GetInt的返回值比0大
1681
01:07:57,940 --> 01:08:00,580
然后我给thankful赋true值  如果是这样
1682
01:08:00,580 --> 01:08:02,270
注意这里有个小技巧
1683
01:08:02,320 --> 01:08:05,330
我将一直这样做  当我用满意时--
1684
01:08:05,330 --> 01:08:08,310
感叹号在这里的意思是"非"  这是一个可速记的
1685
01:08:08,310 --> 01:08:10,110
有几分机灵优雅的符号
1686
01:08:10,500 --> 01:08:13,100
用来说明:"当我不满意  保持这样做"
1687
01:08:13,420 --> 01:08:15,050
所以你可以开始表达--
1688
01:08:15,050 --> 01:08:16,860
即使那个语言有点晦涩--
1689
01:08:17,110 --> 01:08:20,820
你的想法可以用同样的方式说出来
1690
01:08:21,230 --> 01:08:23,980
所以请允许我把这个放到屏幕上
1691
01:08:23,980 --> 01:08:30,940
现在你们可以理解了
1692
01:08:31,010 --> 01:08:32,700
非常对不起--我们使你们变成了
1693
01:08:32,700 --> 01:08:33,770
能够理解这些的人了
1694
01:08:34,500 --> 01:08:37,170
习题集1今晚7:00 将在课程的网站上贴出来
1695
01:08:37,170 --> 01:08:39,200
它将非常清晰地带领你们
1696
01:08:39,200 --> 01:08:40,300
通过这个星期的挑战
1697
01:08:40,300 --> 01:08:45,970
我们下周再见
